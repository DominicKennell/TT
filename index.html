<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ Dynamic Perfect AI Scheduler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        h1, h2, h3 {
            color: #2c3e50;
            margin-bottom: 16px;
        }

        h1 {
            text-align: center;
            font-size: 1.8em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .btn-secondary:hover {
            background: #bdc3c7;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #1e8449;
        }

        .btn-large {
            padding: 16px 32px;
            font-size: 18px;
            width: 100%;
            justify-content: center;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 16px 0;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #34495e;
        }

        .form-control {
            width: 100%;
            padding: 10px 14px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        select.form-control {
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .table-container {
            overflow-x: auto;
            margin: 16px 0;
            border-radius: 8px;
            border: 1px solid #ecf0f1;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f8f9fa;
        }

        tr.selected {
            background: #ebf5fb;
        }

        .summary-box {
            background: linear-gradient(135deg, #667eea20, #764ba220);
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        }

        .summary-box h3 {
            margin-bottom: 12px;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed #bdc3c7;
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .schedule-output {
            background: #1e272e;
            color: #7bed9f;
            border-radius: 12px;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #7f8c8d;
        }

        .modal-close:hover {
            color: #e74c3c;
        }

        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: #ecf0f1;
            padding: 4px;
            border-radius: 12px;
        }

        .tab {
            padding: 10px 16px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 8px;
            font-weight: 600;
            color: #7f8c8d;
            transition: all 0.3s;
        }

        .tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .list-box {
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .list-item {
            padding: 10px 14px;
            border-bottom: 1px solid #ecf0f1;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .list-item:hover {
            background: #f8f9fa;
        }

        .list-item.selected {
            background: #ebf5fb;
        }

        .list-item:last-child {
            border-bottom: none;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-primary {
            background: #667eea20;
            color: #667eea;
        }

        .badge-success {
            background: #27ae6020;
            color: #27ae60;
        }

        .badge-warning {
            background: #f39c1220;
            color: #f39c12;
        }

        .badge-danger {
            background: #e74c3c20;
            color: #e74c3c;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .requirements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }

        .requirement-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .requirement-item input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .requirement-item input[type="number"] {
            width: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        .schedule-day {
            margin-bottom: 24px;
        }

        .schedule-day h3 {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 16px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .schedule-day table {
            border: 1px solid #ddd;
            border-top: none;
        }

        .verification-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
        }

        .verification-item.success {
            color: #27ae60;
        }

        .verification-item.error {
            color: #e74c3c;
        }

        .info-text {
            color: #7f8c8d;
            font-size: 13px;
            font-style: italic;
            margin-top: 8px;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .group-config-item {
            display: grid;
            grid-template-columns: 1fr 1fr 40px;
            gap: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 16px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea10, #764ba210);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 4px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel -->
        <div class="panel">
            <h1>üë®‚Äçüè´ Teacher Management</h1>
            
            <button class="btn btn-primary btn-large" onclick="openConstraintsModal()">
                ‚öôÔ∏è CONFIGURE CONSTRAINTS
            </button>
            <p class="info-text" style="text-align: center;">(Configure subjects, groups, days, time slots, rooms)</p>

            <div style="margin-top: 24px;">
                <h2>üìã Teachers</h2>
                <div class="btn-group">
                    <button class="btn btn-success" onclick="openTeacherModal()">‚ûï Add Teacher</button>
                    <button class="btn btn-secondary" onclick="editSelectedTeacher()">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger" onclick="removeSelectedTeacher()">üóëÔ∏è Remove</button>
                </div>

                <div class="table-container">
                    <table id="teacherTable">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Hours</th>
                                <th>Faculty</th>
                                <th>Courses</th>
                                <th>Days</th>
                                <th>Subjects</th>
                            </tr>
                        </thead>
                        <tbody id="teacherTableBody">
                        </tbody>
                    </table>
                </div>

                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalTeachers">0</div>
                        <div class="stat-label">Teachers</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalHours">0</div>
                        <div class="stat-label">Total Hours</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="requiredHours">0</div>
                        <div class="stat-label">Required Hours</div>
                    </div>
                </div>
            </div>

            <div class="summary-box">
                <h3>üìä Current Constraints</h3>
                <div id="constraintsSummary"></div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <h1>üéØ Schedule Generation</h1>
            <p class="info-text" style="text-align: center; margin-bottom: 20px;">
                Click 'CONFIGURE CONSTRAINTS' to set up subjects, groups, days & rooms, then add teachers
            </p>

            <div style="margin-bottom: 16px;">
                <label style="font-weight: 600; margin-bottom: 8px; display: block;">üß† Algorithm:</label>
                <select id="algorithmSelect" class="form-control" style="max-width: 300px; margin: 0 auto; display: block;">
                    <option value="greedy">Greedy (Fast, Good)</option>
                    <option value="backtracking">Backtracking (Thorough)</option>
                    <option value="sat">SAT Solver (Optimal)</option>
                    <option value="ilp">Integer Linear Programming (Best)</option>
                </select>
                <p class="info-text" style="text-align: center; margin-top: 8px; font-size: 12px;" id="algorithmDescription">
                    Fast heuristic approach - good for most cases
                </p>
            </div>

            <button class="btn btn-primary btn-large" id="generateBtn" onclick="generateSchedule()" disabled>
                üéØ GENERATE PERFECT SCHEDULE
            </button>

            <div class="btn-group" style="justify-content: center; margin-top: 16px;">
                <button class="btn btn-secondary" onclick="exportToPDF()">üìÑ Export to PDF</button>
                <button class="btn btn-danger" onclick="clearSchedule()">üóëÔ∏è Clear Schedule</button>
            </div>

            <div style="margin-top: 24px;">
                <h2>üìÖ Generated Schedule</h2>
                <div class="schedule-output" id="scheduleOutput">
                    Click "GENERATE PERFECT SCHEDULE" to create your schedule...
                </div>
            </div>
        </div>
    </div>

    <!-- Constraints Modal -->
    <div class="modal-overlay" id="constraintsModal">
        <div class="modal" style="max-width: 1000px;">
            <div class="modal-header">
                <h2>‚öôÔ∏è Configure Schedule Constraints</h2>
                <button class="modal-close" onclick="closeConstraintsModal()">√ó</button>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('subjects')">üìö Subjects</button>
                <button class="tab" onclick="switchTab('faculty')">üéì Faculty</button>
                <button class="tab" onclick="switchTab('courses')">üìñ Courses</button>
                <button class="tab" onclick="switchTab('groups')">üë• Groups</button>
                <button class="tab" onclick="switchTab('schedule')">üìÖ Days & Times</button>
                <button class="tab" onclick="switchTab('rooms')">üè´ Rooms</button>
                <button class="tab" onclick="switchTab('dayoff')">üå¥ Day-Off</button>
                <button class="tab" onclick="switchTab('combined')">üîó Combined</button>
            </div>

            <!-- Subjects Tab -->
            <div class="tab-content active" id="tab-subjects">
                <h3>üìö Subject Requirements</h3>
                <p class="info-text">Define how many sessions of each subject are required per class</p>
                
                <div id="requirementsList" class="requirements-grid"></div>
                
                <button class="btn btn-success" onclick="addRequirement()" style="margin-top: 16px;">
                    ‚ûï Add Subject
                </button>
            </div>

            <!-- Faculty Tab -->
            <div class="tab-content" id="tab-faculty">
                <h3>üéì Faculty/Departments</h3>
                <p class="info-text">Define your faculty/departments (e.g., Performing Arts, Art, Media, DCC, Music)</p>
                
                <div class="list-box" id="facultyList"></div>
                
                <div class="btn-group" style="margin-top: 16px;">
                    <button class="btn btn-success" onclick="addFaculty()">‚ûï Add Faculty</button>
                    <button class="btn btn-secondary" onclick="editFaculty()">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger" onclick="removeFaculty()">üóëÔ∏è Remove</button>
                </div>
            </div>

            <!-- Courses Tab -->
            <div class="tab-content" id="tab-courses">
                <h3>üìñ Courses/Levels</h3>
                <p class="info-text">Define your courses/levels (e.g., Level 1, Level 2, Level 3)</p>
                
                <div class="list-box" id="coursesList"></div>
                
                <div class="btn-group" style="margin-top: 16px;">
                    <button class="btn btn-success" onclick="addCourse()">‚ûï Add Course</button>
                    <button class="btn btn-secondary" onclick="editCourse()">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger" onclick="removeCourse()">üóëÔ∏è Remove</button>
                </div>
            </div>

            <!-- Groups Tab -->
            <div class="tab-content" id="tab-groups">
                <h3>üë• Student Groups</h3>
                <p class="info-text">Configure each student group with their faculty and work placement settings</p>
                
                <div style="background: #e8f4fd; border-radius: 8px; padding: 12px; margin-bottom: 16px; border-left: 4px solid #3498db;">
                    <strong>üíº T-Level Work Placement (Industry Placement Day):</strong> 
                    <div style="color: #555; margin-top: 6px; font-size: 13px;">
                        ‚Ä¢ Enable for groups with industry placement days<br>
                        ‚Ä¢ <strong>Counts as a FULL DAY</strong> of sessions toward their hours<br>
                        ‚Ä¢ They will also need a <strong>separate day off</strong> configured in the Day-Off tab<br>
                        ‚Ä¢ Example: T3A has Work Placement on Friday + Day Off on Monday = only in college Tue-Thu
                    </div>
                </div>
                
                <div id="groupsContainer"></div>
                
                <button class="btn btn-success" onclick="addGroup()" style="margin-top: 16px;">
                    ‚ûï Add Student Group
                </button>
            </div>

            <!-- Schedule Tab -->
            <div class="tab-content" id="tab-schedule">
                <div class="grid-2">
                    <div>
                        <h3>üìÖ School Days</h3>
                        <div class="checkbox-group" id="daysCheckboxes"></div>
                    </div>
                    <div>
                        <h3>‚è∞ Time Slots</h3>
                        <div class="list-box" id="timeslotsList"></div>
                        <div class="btn-group" style="margin-top: 12px;">
                            <button class="btn btn-success" onclick="addTimeslot()">‚ûï Add</button>
                            <button class="btn btn-secondary" onclick="editTimeslot()">‚úèÔ∏è Edit</button>
                            <button class="btn btn-danger" onclick="removeTimeslot()">üóëÔ∏è Remove</button>
                        </div>
                        <p class="info-text">Format: HH:MM-HH:MM (e.g., 09:00-10:00)</p>
                    </div>
                </div>
            </div>

            <!-- Rooms Tab -->
            <div class="tab-content" id="tab-rooms">
                <h3>üè´ Classrooms</h3>
                <p class="info-text">Define available classrooms</p>
                
                <div class="list-box" id="roomsList"></div>
                
                <div class="btn-group" style="margin-top: 16px;">
                    <button class="btn btn-success" onclick="addRoom()">‚ûï Add Classroom</button>
                    <button class="btn btn-secondary" onclick="editRoom()">‚úèÔ∏è Edit</button>
                    <button class="btn btn-danger" onclick="removeRoom()">üóëÔ∏è Remove</button>
                </div>
            </div>

            <!-- Day-Off Tab -->
            <div class="tab-content" id="tab-dayoff">
                <h3>üå¥ Group Day-Off Scheduling</h3>
                <p class="info-text">Assign which days each group has off (can select multiple days). Groups are identified by the last character of the student group name.</p>
                
                <div id="dayoffContainer"></div>
            </div>

            <!-- Combined Classes Tab -->
            <div class="tab-content" id="tab-combined">
                <h3>üîó Combined Classes</h3>
                <p class="info-text">Combine student groups to share sessions (useful for room constraints)</p>
                
                <div style="background: #fff3cd; border-radius: 8px; padding: 12px; margin-bottom: 16px; border-left: 4px solid #ffc107;">
                    <strong>‚ö†Ô∏è Last Resort Option:</strong> 
                    <div style="color: #555; margin-top: 6px; font-size: 13px;">
                        ‚Ä¢ Combined groups will share certain sessions in the same room<br>
                        ‚Ä¢ Select which subject(s) they share and how many sessions<br>
                        ‚Ä¢ Groups must have the same faculty to be combined<br>
                        ‚Ä¢ Example: L3A + L3B share 2 Tutorial sessions = both in same room at same time
                    </div>
                </div>
                
                <div id="combinedClassesContainer"></div>
                
                <button class="btn btn-success" onclick="addCombinedClass()" style="margin-top: 16px;">
                    ‚ûï Add Combined Class Group
                </button>
            </div>

            <div class="btn-group" style="justify-content: center; margin-top: 24px; padding-top: 20px; border-top: 2px solid #ecf0f1;">
                <button class="btn btn-primary btn-large" onclick="saveConstraints()" style="max-width: 400px;">
                    üíæ SAVE & APPLY CONFIGURATION
                </button>
                <button class="btn btn-secondary" onclick="resetConstraints()">‚Ü∫ Reset Defaults</button>
                <button class="btn btn-secondary" onclick="closeConstraintsModal()">‚úó Cancel</button>
            </div>
        </div>
    </div>

    <!-- Teacher Modal -->
    <div class="modal-overlay" id="teacherModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h2 id="teacherModalTitle">‚ûï Add Teacher</h2>
                <button class="modal-close" onclick="closeTeacherModal()">√ó</button>
            </div>

            <div class="form-group">
                <label>Teacher Name</label>
                <input type="text" class="form-control" id="teacherName" placeholder="Enter teacher name">
            </div>

            <div class="form-group">
                <label>Maximum Hours per Week</label>
                <input type="number" class="form-control" id="teacherHours" value="20" min="1" max="50">
            </div>

            <div class="form-group">
                <label>Faculty/Department</label>
                <select class="form-control" id="teacherFaculty"></select>
            </div>

            <div class="form-group">
                <label>Courses/Levels Can Teach</label>
                <div class="checkbox-group" id="teacherCourses"></div>
            </div>

            <div class="form-group">
                <label>Available Days</label>
                <div class="checkbox-group" id="teacherDays"></div>
            </div>

            <div class="form-group">
                <label>Subjects Can Teach</label>
                <div class="checkbox-group" id="teacherSubjects"></div>
            </div>

            <div class="btn-group" style="justify-content: center; margin-top: 24px;">
                <button class="btn btn-primary" onclick="saveTeacher()">‚úì Save</button>
                <button class="btn btn-secondary" onclick="closeTeacherModal()">‚úó Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== STATE ====================
        let constraints = {
            requirements: { "Maths": 4, "English": 4, "VOC": 4, "PBL": 4, "Tutorial": 1 },
            faculty: ["Performing Arts", "Art", "Media", "DCC", "Music"],
            courses: ["Level 1", "Level 2", "Level 3", "Level 4", "Level 5"],
            days: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
            timeSlots: ["09:00-10:00", "10:10-11:10", "11:30-12:30", "13:30-14:30", "14:40-15:40", "15:50-16:50"],
            classes: ["L1A", "L2A", "L2B", "L2C", "L3A", "L3B", "L3C"],
            groupConfigs: {},
            rooms: ["Room A101", "Room A102", "Room A103", "Room B201", "Room B202", "Room B203", "Room C301", "Room C302", "Room D401", "Room D402"],
            groupDayOff: { 'A': ['Monday'], 'B': ['Tuesday'], 'C': ['Wednesday'], 'D': ['Thursday'] },
            combinedClasses: []  // Array of { groups: ['L3A', 'L3B'], subject: 'Tutorial', sessions: 1 }
        };

        let teachers = [];
        let schedule = [];
        let selectedTeacherIndex = -1;
        let editingTeacherIndex = -1;

        // Temporary state for modal editing
        let tempConstraints = {};

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            updateConstraintsSummary();
            updateTeacherTable();
            updateStats();
        });

        // ==================== CONSTRAINTS MODAL ====================
        function openConstraintsModal() {
            tempConstraints = JSON.parse(JSON.stringify(constraints));
            renderConstraintsModal();
            document.getElementById('constraintsModal').classList.add('active');
        }

        function closeConstraintsModal() {
            document.getElementById('constraintsModal').classList.remove('active');
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
        }

        function renderConstraintsModal() {
            renderRequirements();
            renderFacultyList();
            renderCoursesList();
            renderGroupsContainer();
            renderDaysCheckboxes();
            renderTimeslotsList();
            renderRoomsList();
            renderDayoffContainer();
            renderCombinedClassesContainer();
        }

        function renderRequirements() {
            const container = document.getElementById('requirementsList');
            container.innerHTML = '';
            
            Object.entries(tempConstraints.requirements).forEach(([subject, count], index) => {
                container.innerHTML += `
                    <div class="requirement-item" data-index="${index}">
                        <input type="text" value="${subject}" onchange="updateRequirement(${index}, 'subject', this.value)">
                        <input type="number" value="${count}" min="0" max="10" onchange="updateRequirement(${index}, 'count', this.value)">
                        <button class="btn btn-danger" onclick="removeRequirement('${subject}')" style="padding: 8px;">üóëÔ∏è</button>
                    </div>
                `;
            });
        }

        function updateRequirement(index, field, value) {
            const keys = Object.keys(tempConstraints.requirements);
            const oldKey = keys[index];
            
            if (field === 'subject') {
                const count = tempConstraints.requirements[oldKey];
                delete tempConstraints.requirements[oldKey];
                tempConstraints.requirements[value] = count;
            } else {
                tempConstraints.requirements[oldKey] = parseInt(value) || 0;
            }
        }

        function addRequirement() {
            const subject = prompt('Enter subject name:');
            if (subject && subject.trim()) {
                tempConstraints.requirements[subject.trim()] = 1;
                renderRequirements();
            }
        }

        function removeRequirement(subject) {
            delete tempConstraints.requirements[subject];
            renderRequirements();
        }

        function renderFacultyList() {
            const container = document.getElementById('facultyList');
            container.innerHTML = tempConstraints.faculty.map((f, i) => `
                <div class="list-item ${i === selectedFacultyIndex ? 'selected' : ''}" onclick="selectFaculty(${i})">
                    ${f}
                </div>
            `).join('');
        }

        let selectedFacultyIndex = -1;
        function selectFaculty(index) {
            selectedFacultyIndex = index;
            renderFacultyList();
        }

        function addFaculty() {
            const faculty = prompt('Enter faculty/department name:');
            if (faculty && faculty.trim()) {
                tempConstraints.faculty.push(faculty.trim());
                renderFacultyList();
            }
        }

        function editFaculty() {
            if (selectedFacultyIndex < 0) {
                alert('Please select a faculty to edit!');
                return;
            }
            const newName = prompt('Edit faculty name:', tempConstraints.faculty[selectedFacultyIndex]);
            if (newName && newName.trim()) {
                tempConstraints.faculty[selectedFacultyIndex] = newName.trim();
                renderFacultyList();
            }
        }

        function removeFaculty() {
            if (selectedFacultyIndex < 0) {
                alert('Please select a faculty to remove!');
                return;
            }
            tempConstraints.faculty.splice(selectedFacultyIndex, 1);
            selectedFacultyIndex = -1;
            renderFacultyList();
        }

        let selectedCourseIndex = -1;
        function renderCoursesList() {
            const container = document.getElementById('coursesList');
            container.innerHTML = tempConstraints.courses.map((c, i) => `
                <div class="list-item ${i === selectedCourseIndex ? 'selected' : ''}" onclick="selectCourse(${i})">
                    ${c}
                </div>
            `).join('');
        }

        function selectCourse(index) {
            selectedCourseIndex = index;
            renderCoursesList();
        }

        function addCourse() {
            const course = prompt('Enter course/level name:');
            if (course && course.trim()) {
                tempConstraints.courses.push(course.trim());
                renderCoursesList();
            }
        }

        function editCourse() {
            if (selectedCourseIndex < 0) {
                alert('Please select a course to edit!');
                return;
            }
            const newName = prompt('Edit course name:', tempConstraints.courses[selectedCourseIndex]);
            if (newName && newName.trim()) {
                tempConstraints.courses[selectedCourseIndex] = newName.trim();
                renderCoursesList();
            }
        }

        function removeCourse() {
            if (selectedCourseIndex < 0) {
                alert('Please select a course to remove!');
                return;
            }
            tempConstraints.courses.splice(selectedCourseIndex, 1);
            selectedCourseIndex = -1;
            renderCoursesList();
        }

        function renderGroupsContainer() {
            const container = document.getElementById('groupsContainer');
            const allFaculties = ['English', 'Maths', ...tempConstraints.faculty];
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr 150px 180px 40px; gap: 10px; padding: 10px; background: #34495e; color: white; border-radius: 8px 8px 0 0; font-weight: 600; font-size: 13px;">
                    <div>Group Name</div>
                    <div>Faculty</div>
                    <div>üíº Work Placement</div>
                    <div>Placement Day</div>
                    <div></div>
                </div>
            ` + tempConstraints.classes.map((cls, i) => {
                const config = tempConstraints.groupConfigs[cls] || { faculty: allFaculties[0], workPlacement: false, workPlacementDay: '' };
                const hasWorkPlacement = config.workPlacement || false;
                const workPlacementDay = config.workPlacementDay || '';
                
                return `
                    <div style="display: grid; grid-template-columns: 1fr 1fr 150px 180px 40px; gap: 10px; padding: 12px; background: #f8f9fa; border: 1px solid #ecf0f1; border-top: none; align-items: center;">
                        <input type="text" class="form-control" value="${cls}" 
                               onchange="updateGroupName(${i}, this.value)" style="margin: 0;">
                        <select class="form-control" onchange="updateGroupFaculty('${cls}', this.value)" style="margin: 0;">
                            ${allFaculties.map(f => `<option value="${f}" ${config.faculty === f ? 'selected' : ''}>${f}</option>`).join('')}
                        </select>
                        <div style="text-align: center;">
                            <input type="checkbox" id="wp-${cls}" ${hasWorkPlacement ? 'checked' : ''} 
                                   onchange="updateWorkPlacement('${cls}', this.checked)"
                                   style="width: 20px; height: 20px; cursor: pointer;">
                            <label for="wp-${cls}" style="margin-left: 5px; cursor: pointer; font-size: 12px;">T-Level</label>
                        </div>
                        <select class="form-control" onchange="updateWorkPlacementDay('${cls}', this.value)" 
                                style="margin: 0;" ${!hasWorkPlacement ? 'disabled' : ''}>
                            <option value="">Select day...</option>
                            ${tempConstraints.days.map(d => `<option value="${d}" ${workPlacementDay === d ? 'selected' : ''}>${d}</option>`).join('')}
                        </select>
                        <button class="btn btn-danger" onclick="removeGroup(${i})" style="padding: 8px;">üóëÔ∏è</button>
                    </div>
                `;
            }).join('');
        }

        function updateWorkPlacement(className, enabled) {
            if (!tempConstraints.groupConfigs[className]) {
                tempConstraints.groupConfigs[className] = {};
            }
            tempConstraints.groupConfigs[className].workPlacement = enabled;
            if (!enabled) {
                tempConstraints.groupConfigs[className].workPlacementDay = '';
            }
            renderGroupsContainer();
        }

        function updateWorkPlacementDay(className, day) {
            if (!tempConstraints.groupConfigs[className]) {
                tempConstraints.groupConfigs[className] = {};
            }
            tempConstraints.groupConfigs[className].workPlacementDay = day;
        }

        function updateGroupName(index, newName) {
            const oldName = tempConstraints.classes[index];
            tempConstraints.classes[index] = newName;
            
            if (tempConstraints.groupConfigs[oldName]) {
                tempConstraints.groupConfigs[newName] = tempConstraints.groupConfigs[oldName];
                delete tempConstraints.groupConfigs[oldName];
            }
        }

        function updateGroupFaculty(className, faculty) {
            if (!tempConstraints.groupConfigs[className]) {
                tempConstraints.groupConfigs[className] = {};
            }
            tempConstraints.groupConfigs[className].faculty = faculty;
        }

        function addGroup() {
            const groupName = prompt('Enter student group name:');
            if (groupName && groupName.trim()) {
                tempConstraints.classes.push(groupName.trim());
                tempConstraints.groupConfigs[groupName.trim()] = { 
                    faculty: tempConstraints.faculty[0] || '',
                    workPlacement: false,
                    workPlacementDay: ''
                };
                renderGroupsContainer();
            }
        }

        function removeGroup(index) {
            const className = tempConstraints.classes[index];
            tempConstraints.classes.splice(index, 1);
            delete tempConstraints.groupConfigs[className];
            renderGroupsContainer();
        }

        function renderDaysCheckboxes() {
            const container = document.getElementById('daysCheckboxes');
            const allDays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
            
            container.innerHTML = allDays.map(day => `
                <div class="checkbox-item">
                    <input type="checkbox" id="day-${day}" ${tempConstraints.days.includes(day) ? 'checked' : ''}>
                    <label for="day-${day}">${day}</label>
                </div>
            `).join('');
        }

        let selectedTimeslotIndex = -1;
        function renderTimeslotsList() {
            const container = document.getElementById('timeslotsList');
            container.innerHTML = tempConstraints.timeSlots.map((t, i) => `
                <div class="list-item ${i === selectedTimeslotIndex ? 'selected' : ''}" onclick="selectTimeslot(${i})">
                    ${t}
                </div>
            `).join('');
        }

        function selectTimeslot(index) {
            selectedTimeslotIndex = index;
            renderTimeslotsList();
        }

        function addTimeslot() {
            const slot = prompt('Enter time slot (HH:MM-HH:MM):');
            if (slot && slot.trim()) {
                tempConstraints.timeSlots.push(slot.trim());
                renderTimeslotsList();
            }
        }

        function editTimeslot() {
            if (selectedTimeslotIndex < 0) {
                alert('Please select a time slot to edit!');
                return;
            }
            const newSlot = prompt('Edit time slot:', tempConstraints.timeSlots[selectedTimeslotIndex]);
            if (newSlot && newSlot.trim()) {
                tempConstraints.timeSlots[selectedTimeslotIndex] = newSlot.trim();
                renderTimeslotsList();
            }
        }

        function removeTimeslot() {
            if (selectedTimeslotIndex < 0) {
                alert('Please select a time slot to remove!');
                return;
            }
            tempConstraints.timeSlots.splice(selectedTimeslotIndex, 1);
            selectedTimeslotIndex = -1;
            renderTimeslotsList();
        }

        let selectedRoomIndex = -1;
        function renderRoomsList() {
            const container = document.getElementById('roomsList');
            container.innerHTML = tempConstraints.rooms.map((r, i) => `
                <div class="list-item ${i === selectedRoomIndex ? 'selected' : ''}" onclick="selectRoom(${i})">
                    ${r}
                </div>
            `).join('');
        }

        function selectRoom(index) {
            selectedRoomIndex = index;
            renderRoomsList();
        }

        function addRoom() {
            const room = prompt('Enter classroom name:');
            if (room && room.trim()) {
                tempConstraints.rooms.push(room.trim());
                renderRoomsList();
            }
        }

        function editRoom() {
            if (selectedRoomIndex < 0) {
                alert('Please select a classroom to edit!');
                return;
            }
            const newRoom = prompt('Edit classroom name:', tempConstraints.rooms[selectedRoomIndex]);
            if (newRoom && newRoom.trim()) {
                tempConstraints.rooms[selectedRoomIndex] = newRoom.trim();
                renderRoomsList();
            }
        }

        function removeRoom() {
            if (selectedRoomIndex < 0) {
                alert('Please select a classroom to remove!');
                return;
            }
            tempConstraints.rooms.splice(selectedRoomIndex, 1);
            selectedRoomIndex = -1;
            renderRoomsList();
        }

        function renderDayoffContainer() {
            const container = document.getElementById('dayoffContainer');
            const groupIds = new Set();
            
            tempConstraints.classes.forEach(cls => {
                if (cls) {
                    const groupId = cls[cls.length - 1].toUpperCase();
                    if (/[A-Z]/.test(groupId)) {
                        groupIds.add(groupId);
                    }
                }
            });

            const sortedGroups = Array.from(groupIds).sort();
            
            container.innerHTML = sortedGroups.map(groupId => {
                const currentDaysOff = tempConstraints.groupDayOff[groupId] || [];
                // Ensure it's an array (handle legacy single string values)
                const daysOffArray = Array.isArray(currentDaysOff) ? currentDaysOff : (currentDaysOff ? [currentDaysOff] : []);
                const classesInGroup = tempConstraints.classes.filter(c => c.endsWith(groupId));
                
                return `
                    <div class="dayoff-group-item" style="background: #f8f9fa; border-radius: 8px; padding: 16px; margin-bottom: 12px;">
                        <div style="margin-bottom: 10px;">
                            <strong>Group ${groupId}</strong> 
                            <span class="info-text">(${classesInGroup.join(', ') || '-'})</span>
                            <span class="badge ${daysOffArray.length > 0 ? 'badge-warning' : 'badge-success'}" style="margin-left: 10px;">
                                ${daysOffArray.length} day${daysOffArray.length !== 1 ? 's' : ''} off
                            </span>
                        </div>
                        <div class="checkbox-group" style="background: white; padding: 10px; border-radius: 6px;">
                            ${tempConstraints.days.map(d => `
                                <div class="checkbox-item">
                                    <input type="checkbox" 
                                           id="dayoff-${groupId}-${d}" 
                                           ${daysOffArray.includes(d) ? 'checked' : ''}
                                           onchange="updateDayOff('${groupId}', '${d}', this.checked)">
                                    <label for="dayoff-${groupId}-${d}">${d}</label>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateDayOff(groupId, day, isChecked) {
            // Ensure the groupDayOff entry is an array
            if (!tempConstraints.groupDayOff[groupId]) {
                tempConstraints.groupDayOff[groupId] = [];
            }
            // Convert legacy string to array if needed
            if (!Array.isArray(tempConstraints.groupDayOff[groupId])) {
                tempConstraints.groupDayOff[groupId] = tempConstraints.groupDayOff[groupId] ? 
                    [tempConstraints.groupDayOff[groupId]] : [];
            }
            
            if (isChecked) {
                if (!tempConstraints.groupDayOff[groupId].includes(day)) {
                    tempConstraints.groupDayOff[groupId].push(day);
                }
            } else {
                tempConstraints.groupDayOff[groupId] = tempConstraints.groupDayOff[groupId].filter(d => d !== day);
            }
            
            // Clean up empty arrays
            if (tempConstraints.groupDayOff[groupId].length === 0) {
                delete tempConstraints.groupDayOff[groupId];
            }
            
            // Re-render to update badge
            renderDayoffContainer();
        }

        // ==================== COMBINED CLASSES ====================
        function renderCombinedClassesContainer() {
            const container = document.getElementById('combinedClassesContainer');
            
            if (!tempConstraints.combinedClasses) {
                tempConstraints.combinedClasses = [];
            }
            
            if (tempConstraints.combinedClasses.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #7f8c8d;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üîó</div>
                        <p>No combined classes configured</p>
                        <p class="info-text">Click "Add Combined Class Group" to combine groups for shared sessions</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = tempConstraints.combinedClasses.map((combo, index) => {
                const groupsDisplay = combo.groups.join(' + ');
                
                return `
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 16px; margin-bottom: 12px; border-left: 4px solid #9b59b6;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                            <div>
                                <strong style="font-size: 16px;">üîó ${groupsDisplay}</strong>
                                <span class="badge badge-primary" style="margin-left: 10px;">${combo.sessions} shared ${combo.subject} session${combo.sessions > 1 ? 's' : ''}</span>
                            </div>
                            <button class="btn btn-danger" onclick="removeCombinedClass(${index})" style="padding: 6px 12px;">üóëÔ∏è Remove</button>
                        </div>
                        
                        <div class="grid-2" style="gap: 12px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 12px;">Groups to Combine</label>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px; background: white; padding: 10px; border-radius: 6px;">
                                    ${tempConstraints.classes.map(cls => `
                                        <div class="checkbox-item">
                                            <input type="checkbox" 
                                                   id="combo-${index}-${cls}"
                                                   ${combo.groups.includes(cls) ? 'checked' : ''}
                                                   onchange="updateCombinedClassGroups(${index}, '${cls}', this.checked)">
                                            <label for="combo-${index}-${cls}" style="font-size: 13px;">${cls}</label>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            <div>
                                <div class="form-group" style="margin: 0 0 8px 0;">
                                    <label style="font-size: 12px;">Shared Subject</label>
                                    <select class="form-control" onchange="updateCombinedClassSubject(${index}, this.value)" style="margin: 0;">
                                        ${Object.keys(tempConstraints.requirements).map(subj => `
                                            <option value="${subj}" ${combo.subject === subj ? 'selected' : ''}>${subj}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                
                                <div class="form-group" style="margin: 0;">
                                    <label style="font-size: 12px;">Number of Shared Sessions</label>
                                    <input type="number" class="form-control" value="${combo.sessions}" min="1" max="10"
                                           onchange="updateCombinedClassSessions(${index}, this.value)" style="margin: 0;">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addCombinedClass() {
            if (!tempConstraints.combinedClasses) {
                tempConstraints.combinedClasses = [];
            }
            
            const subjects = Object.keys(tempConstraints.requirements);
            const defaultSubject = subjects.includes('Tutorial') ? 'Tutorial' : subjects[0];
            
            tempConstraints.combinedClasses.push({
                groups: [],
                subject: defaultSubject,
                sessions: 1
            });
            
            renderCombinedClassesContainer();
        }

        function removeCombinedClass(index) {
            tempConstraints.combinedClasses.splice(index, 1);
            renderCombinedClassesContainer();
        }

        function updateCombinedClassGroups(index, className, isChecked) {
            const combo = tempConstraints.combinedClasses[index];
            
            if (isChecked) {
                if (!combo.groups.includes(className)) {
                    combo.groups.push(className);
                }
            } else {
                combo.groups = combo.groups.filter(g => g !== className);
            }
            
            renderCombinedClassesContainer();
        }

        function updateCombinedClassSubject(index, subject) {
            tempConstraints.combinedClasses[index].subject = subject;
        }

        function updateCombinedClassSessions(index, sessions) {
            tempConstraints.combinedClasses[index].sessions = parseInt(sessions) || 1;
        }


        function saveConstraints() {
            // Collect days from checkboxes
            const allDays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
            tempConstraints.days = allDays.filter(day => document.getElementById(`day-${day}`)?.checked);

            if (Object.keys(tempConstraints.requirements).length === 0) {
                alert('Please define at least one subject requirement!');
                return;
            }
            if (tempConstraints.days.length === 0) {
                alert('Please select at least one day!');
                return;
            }
            if (tempConstraints.timeSlots.length === 0) {
                alert('Please define at least one time slot!');
                return;
            }
            if (tempConstraints.classes.length === 0) {
                alert('Please define at least one student group!');
                return;
            }
            if (tempConstraints.rooms.length === 0) {
                alert('Please define at least one classroom!');
                return;
            }

            constraints = JSON.parse(JSON.stringify(tempConstraints));
            
            const totalPerClass = Object.values(constraints.requirements).reduce((a, b) => a + b, 0);
            const totalNeeded = totalPerClass * constraints.classes.length;
            
            updateConstraintsSummary();
            updateStats();
            closeConstraintsModal();
            
            alert(`Configuration saved!\n\nHours per class: ${totalPerClass}\nTotal hours needed: ${totalNeeded}`);
        }

        function resetConstraints() {
            if (confirm('Reset all constraints to defaults?')) {
                tempConstraints = {
                    requirements: { "Maths": 4, "English": 4, "VOC": 4, "PBL": 4, "Tutorial": 1 },
                    faculty: ["Performing Arts", "Art", "Media", "DCC", "Music"],
                    courses: ["Level 1", "Level 2", "Level 3", "Level 4", "Level 5"],
                    days: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
                    timeSlots: ["09:00-10:00", "10:10-11:10", "11:30-12:30", "13:30-14:30", "14:40-15:40", "15:50-16:50"],
                    classes: ["L1A", "L2A", "L2B", "L2C", "L3A", "L3B", "L3C"],
                    groupConfigs: {},
                    rooms: ["Room A101", "Room A102", "Room A103", "Room B201", "Room B202", "Room B203", "Room C301", "Room C302", "Room D401", "Room D402"],
                    groupDayOff: { 'A': ['Monday'], 'B': ['Tuesday'], 'C': ['Wednesday'], 'D': ['Thursday'] },
                    combinedClasses: []
                };
                renderConstraintsModal();
            }
        }

        function updateConstraintsSummary() {
            const container = document.getElementById('constraintsSummary');
            const totalPerClass = Object.values(constraints.requirements).reduce((a, b) => a + b, 0);
            
            let html = '<div class="summary-item"><strong>üìö Requirements:</strong></div>';
            Object.entries(constraints.requirements).forEach(([subject, count]) => {
                html += `<div class="summary-item"><span>${subject}</span><span>${count}x</span></div>`;
            });
            
            html += `<div class="summary-item" style="border-top: 2px solid #bdc3c7; margin-top: 8px; padding-top: 8px;">
                        <span><strong>Hours per class</strong></span><span><strong>${totalPerClass}</strong></span>
                     </div>`;
            
            html += `<div class="summary-item"><span>üìÖ Days</span><span>${constraints.days.length}</span></div>`;
            html += `<div class="summary-item"><span>‚è∞ Time Slots</span><span>${constraints.timeSlots.length}</span></div>`;
            html += `<div class="summary-item"><span>üë• Classes</span><span>${constraints.classes.length}</span></div>`;
            html += `<div class="summary-item"><span>üè´ Rooms</span><span>${constraints.rooms.length}</span></div>`;
            
            // Add day-off summary
            const groupsWithDayOff = Object.keys(constraints.groupDayOff).length;
            if (groupsWithDayOff > 0) {
                html += `<div class="summary-item"><span>üå¥ Groups w/ days off</span><span>${groupsWithDayOff}</span></div>`;
            }
            
            // Add work placement summary
            const groupsWithWP = constraints.classes.filter(cls => {
                const config = constraints.groupConfigs[cls] || {};
                return config.workPlacement && config.workPlacementDay;
            }).length;
            if (groupsWithWP > 0) {
                html += `<div class="summary-item"><span>üíº T-Level Groups</span><span>${groupsWithWP}</span></div>`;
            }
            
            // Add combined classes summary
            const combinedCount = (constraints.combinedClasses || []).length;
            if (combinedCount > 0) {
                html += `<div class="summary-item"><span>üîó Combined Groups</span><span>${combinedCount}</span></div>`;
            }
            
            container.innerHTML = html;
        }

        // ==================== TEACHER MODAL ====================
        function openTeacherModal(editIndex = -1) {
            editingTeacherIndex = editIndex;
            
            const modal = document.getElementById('teacherModal');
            const title = document.getElementById('teacherModalTitle');
            
            // Populate faculty dropdown
            const facultySelect = document.getElementById('teacherFaculty');
            facultySelect.innerHTML = constraints.faculty.map(f => 
                `<option value="${f}">${f}</option>`
            ).join('');
            
            // Populate courses checkboxes
            const coursesContainer = document.getElementById('teacherCourses');
            coursesContainer.innerHTML = constraints.courses.map(c => `
                <div class="checkbox-item">
                    <input type="checkbox" id="tc-${c}" value="${c}">
                    <label for="tc-${c}">${c}</label>
                </div>
            `).join('');
            
            // Populate days checkboxes
            const daysContainer = document.getElementById('teacherDays');
            daysContainer.innerHTML = constraints.days.map(d => `
                <div class="checkbox-item">
                    <input type="checkbox" id="td-${d}" value="${d}" checked>
                    <label for="td-${d}">${d}</label>
                </div>
            `).join('');
            
            // Populate subjects checkboxes
            const subjectsContainer = document.getElementById('teacherSubjects');
            subjectsContainer.innerHTML = Object.keys(constraints.requirements).map(s => `
                <div class="checkbox-item">
                    <input type="checkbox" id="ts-${s}" value="${s}">
                    <label for="ts-${s}">${s}</label>
                </div>
            `).join('');
            
            if (editIndex >= 0) {
                title.textContent = '‚úèÔ∏è Edit Teacher';
                const teacher = teachers[editIndex];
                
                document.getElementById('teacherName').value = teacher.name;
                document.getElementById('teacherHours').value = teacher.maxHours;
                document.getElementById('teacherFaculty').value = teacher.faculty || '';
                
                teacher.courses?.forEach(c => {
                    const cb = document.getElementById(`tc-${c}`);
                    if (cb) cb.checked = true;
                });
                
                constraints.days.forEach(d => {
                    const cb = document.getElementById(`td-${d}`);
                    if (cb) cb.checked = teacher.days.includes(d);
                });
                
                teacher.subjects.forEach(s => {
                    const cb = document.getElementById(`ts-${s}`);
                    if (cb) cb.checked = true;
                });
            } else {
                title.textContent = '‚ûï Add Teacher';
                document.getElementById('teacherName').value = '';
                document.getElementById('teacherHours').value = '20';
            }
            
            modal.classList.add('active');
        }

        function closeTeacherModal() {
            document.getElementById('teacherModal').classList.remove('active');
            editingTeacherIndex = -1;
        }

        function saveTeacher() {
            const name = document.getElementById('teacherName').value.trim();
            const maxHours = parseInt(document.getElementById('teacherHours').value) || 20;
            const faculty = document.getElementById('teacherFaculty').value;
            
            const courses = [];
            constraints.courses.forEach(c => {
                if (document.getElementById(`tc-${c}`)?.checked) courses.push(c);
            });
            
            const days = [];
            constraints.days.forEach(d => {
                if (document.getElementById(`td-${d}`)?.checked) days.push(d);
            });
            
            const subjects = [];
            Object.keys(constraints.requirements).forEach(s => {
                if (document.getElementById(`ts-${s}`)?.checked) subjects.push(s);
            });
            
            if (!name) {
                alert('Please enter teacher name!');
                return;
            }
            if (days.length === 0) {
                alert('Please select at least one day!');
                return;
            }
            if (subjects.length === 0) {
                alert('Please select at least one subject!');
                return;
            }
            
            // Check for duplicate names
            const isDuplicate = teachers.some((t, i) => 
                t.name.toLowerCase() === name.toLowerCase() && i !== editingTeacherIndex
            );
            if (isDuplicate) {
                alert('A teacher with this name already exists!');
                return;
            }
            
            const teacher = { name, maxHours, faculty, courses, days, subjects };
            
            if (editingTeacherIndex >= 0) {
                teachers[editingTeacherIndex] = teacher;
            } else {
                teachers.push(teacher);
            }
            
            updateTeacherTable();
            updateStats();
            closeTeacherModal();
        }

        function updateTeacherTable() {
            const tbody = document.getElementById('teacherTableBody');
            tbody.innerHTML = teachers.map((t, i) => `
                <tr class="${i === selectedTeacherIndex ? 'selected' : ''}" onclick="selectTeacher(${i})">
                    <td>${t.name}</td>
                    <td>${t.maxHours}</td>
                    <td>${t.faculty || '-'}</td>
                    <td>${t.courses?.join(', ') || '-'}</td>
                    <td>${t.days.map(d => d.substring(0, 3)).join(', ')}</td>
                    <td>${t.subjects.join(', ')}</td>
                </tr>
            `).join('');
            
            document.getElementById('generateBtn').disabled = teachers.length === 0;
        }

        function selectTeacher(index) {
            selectedTeacherIndex = index;
            updateTeacherTable();
        }

        function editSelectedTeacher() {
            if (selectedTeacherIndex < 0) {
                alert('Please select a teacher to edit!');
                return;
            }
            openTeacherModal(selectedTeacherIndex);
        }

        function removeSelectedTeacher() {
            if (selectedTeacherIndex < 0) {
                alert('Please select a teacher to remove!');
                return;
            }
            if (confirm(`Remove teacher "${teachers[selectedTeacherIndex].name}"?`)) {
                teachers.splice(selectedTeacherIndex, 1);
                selectedTeacherIndex = -1;
                updateTeacherTable();
                updateStats();
            }
        }

        function updateStats() {
            const totalTeachers = teachers.length;
            const totalHours = teachers.reduce((sum, t) => sum + t.maxHours, 0);
            const totalPerClass = Object.values(constraints.requirements).reduce((a, b) => a + b, 0);
            const requiredHours = totalPerClass * constraints.classes.length;
            
            document.getElementById('totalTeachers').textContent = totalTeachers;
            document.getElementById('totalHours').textContent = totalHours;
            document.getElementById('requiredHours').textContent = requiredHours;
        }

        // ==================== SCHEDULE GENERATION ====================
        
        // Algorithm description updater
        document.addEventListener('DOMContentLoaded', function() {
            const select = document.getElementById('algorithmSelect');
            if (select) {
                select.addEventListener('change', updateAlgorithmDescription);
            }
        });
        
        function updateAlgorithmDescription() {
            const algo = document.getElementById('algorithmSelect').value;
            const desc = document.getElementById('algorithmDescription');
            const descriptions = {
                'greedy': 'Fast heuristic approach - good for most cases',
                'backtracking': 'Systematic search with backtracking - guarantees solution if exists',
                'sat': 'Boolean satisfiability solver - finds optimal valid solution',
                'ilp': 'Integer Linear Programming - mathematically optimal solution'
            };
            desc.textContent = descriptions[algo] || '';
        }
        
        function generateSchedule() {
            if (teachers.length === 0) {
                alert('Please add teachers before generating schedule!');
                return;
            }
            
            // Validate teachers for all subjects
            const requiredSubjects = new Set(Object.keys(constraints.requirements));
            const availableSubjects = new Set();
            teachers.forEach(t => t.subjects.forEach(s => availableSubjects.add(s)));
            
            const missing = [...requiredSubjects].filter(s => !availableSubjects.has(s));
            if (missing.length > 0) {
                alert(`No teachers available for: ${missing.join(', ')}\n\nPlease add teachers who can teach these subjects!`);
                return;
            }
            
            const output = document.getElementById('scheduleOutput');
            const algorithm = document.getElementById('algorithmSelect').value;
            
            output.textContent = `üéØ Generating Schedule using ${algorithm.toUpperCase()} algorithm...\n` + '='.repeat(70) + '\n\n';
            
            let result;
            
            switch(algorithm) {
                case 'backtracking':
                    result = runBacktrackingScheduler();
                    break;
                case 'sat':
                    result = runSATScheduler();
                    break;
                case 'ilp':
                    result = runILPScheduler();
                    break;
                case 'greedy':
                default:
                    result = runPerfectScheduler();
                    break;
            }
            
            if (result) {
                schedule = result;
                displaySchedule();
            } else {
                output.textContent += '\n‚ùå Could not generate perfect schedule\n';
                alert('Could not generate schedule. Please check constraints and teacher availability.');
            }
        }

        function runPerfectScheduler() {
            const output = document.getElementById('scheduleOutput');
            
            // Step 1: Auto-generate classes
            output.textContent += 'üìã Step 1: Auto-Generating Classes with Faculty Matching...\n';
            output.textContent += '-'.repeat(70) + '\n\n';
            
            const totalPerClass = Object.values(constraints.requirements).reduce((a, b) => a + b, 0);
            const totalTeacherHours = teachers.reduce((sum, t) => sum + t.maxHours, 0);
            let totalClassHours = totalPerClass * constraints.classes.length;
            
            // Calculate savings from combined classes
            const combinedClasses = constraints.combinedClasses || [];
            let combinedSavings = 0;
            combinedClasses.forEach(combo => {
                if (combo.groups.length >= 2) {
                    // Each additional group in a combo saves sessions
                    // e.g., 2 groups sharing 1 session saves 1 session (2 would become 1)
                    combinedSavings += combo.sessions * (combo.groups.length - 1);
                }
            });
            
            const adjustedClassHours = totalClassHours - combinedSavings;
            
            output.textContent += `Teacher hours available: ${totalTeacherHours}\n`;
            output.textContent += `Class hours needed: ${totalClassHours}`;
            if (combinedSavings > 0) {
                output.textContent += ` (${adjustedClassHours} after combined class savings of ${combinedSavings})`;
            }
            output.textContent += '\n\n';
            
            // Build teacher lookup by subject
            const subjectTeachers = {};
            teachers.forEach(t => {
                t.subjects.forEach(s => {
                    if (!subjectTeachers[s]) subjectTeachers[s] = [];
                    subjectTeachers[s].push(t);
                });
            });
            
            // Pre-process combined classes to track which sessions are shared
            const combinedSessionsMap = {}; // { 'className-subject': { reducedBy: N, combineWith: [...], isPrimary: bool } }
            
            if (combinedClasses.length > 0) {
                output.textContent += 'üîó Processing Combined Classes...\n';
                
                for (const combo of combinedClasses) {
                    if (combo.groups.length < 2) continue;
                    
                    const primaryGroup = combo.groups[0];
                    const otherGroups = combo.groups.slice(1);
                    
                    output.textContent += `  ${combo.groups.join(' + ')}: ${combo.sessions}x shared ${combo.subject}\n`;
                    
                    // Primary group keeps its sessions but they become combined
                    const primaryKey = `${primaryGroup}-${combo.subject}`;
                    if (!combinedSessionsMap[primaryKey]) {
                        combinedSessionsMap[primaryKey] = { reducedBy: 0, combineWith: [], isPrimary: true, sessions: combo.sessions };
                    }
                    combinedSessionsMap[primaryKey].combineWith.push(...otherGroups);
                    combinedSessionsMap[primaryKey].combinedSessions = combo.sessions;
                    
                    // Other groups have their requirements reduced
                    for (const otherGroup of otherGroups) {
                        const otherKey = `${otherGroup}-${combo.subject}`;
                        if (!combinedSessionsMap[otherKey]) {
                            combinedSessionsMap[otherKey] = { reducedBy: 0, combineWith: [], isPrimary: false };
                        }
                        combinedSessionsMap[otherKey].reducedBy += combo.sessions;
                        combinedSessionsMap[otherKey].combinedWith = primaryGroup;
                    }
                }
                output.textContent += '\n';
            }
            
            const classesToSchedule = [];
            const teacherHoursUsed = {};
            teachers.forEach(t => teacherHoursUsed[t.name] = 0);
            
            let roomIdx = 0;
            
            // Assign classes
            for (const className of constraints.classes) {
                const group = className[className.length - 1];
                const groupConfig = constraints.groupConfigs[className] || {};
                const groupFaculty = groupConfig.faculty || '';
                
                for (const [subject, count] of Object.entries(constraints.requirements)) {
                    // Check if this class-subject has combined session adjustments
                    const comboKey = `${className}-${subject}`;
                    const comboInfo = combinedSessionsMap[comboKey];
                    
                    // Calculate effective count (reduced for non-primary combined groups)
                    let effectiveCount = count;
                    if (comboInfo && !comboInfo.isPrimary) {
                        effectiveCount = Math.max(0, count - comboInfo.reducedBy);
                    }
                    
                    for (let i = 0; i < effectiveCount; i++) {
                        // Check if this is a combined session (for primary group)
                        const isCombinedSession = comboInfo && comboInfo.isPrimary && i < comboInfo.combinedSessions;
                        
                        // Score teachers
                        const teacherScores = subjectTeachers[subject].map(t => {
                            let score = 0;
                            
                            // Faculty match
                            if (t.faculty && t.faculty === groupFaculty) score += 100;
                            
                            // Remaining capacity
                            const remaining = t.maxHours - teacherHoursUsed[t.name];
                            if (remaining > 0) score += remaining * 10;
                            
                            // Underutilization bonus
                            if (teacherHoursUsed[t.name] < t.maxHours * 0.5) score += 20;
                            
                            // Day availability
                            const classDays = getAvailableDaysForClass(className);
                            const availableDays = t.days.filter(d => classDays.includes(d));
                            score += availableDays.length * 2;
                            
                            return { teacher: t, score, availableDays };
                        }).sort((a, b) => b.score - a.score);
                        
                        const best = teacherScores[0];
                        const room = constraints.rooms[roomIdx % constraints.rooms.length];
                        roomIdx++;
                        
                        const sessionInfo = {
                            teacher: best.teacher.name,
                            class: className,
                            subject: subject,
                            room: room,
                            days: best.availableDays.length > 0 ? best.availableDays : getAvailableDaysForClass(className)
                        };
                        
                        // Mark as combined if applicable
                        if (isCombinedSession) {
                            sessionInfo.isCombined = true;
                            sessionInfo.combinedGroups = [className, ...comboInfo.combineWith];
                            sessionInfo.displayClass = sessionInfo.combinedGroups.join(' + ');
                        }
                        
                        classesToSchedule.push(sessionInfo);
                        teacherHoursUsed[best.teacher.name]++;
                    }
                }
            }
            
            // Redistribution phase
            output.textContent += 'Phase 2: Intelligent Redistribution...\n';
            
            let iterations = 0;
            while (iterations < 10) {
                iterations++;
                
                const overAllocated = teachers.filter(t => teacherHoursUsed[t.name] > t.maxHours);
                const underAllocated = teachers.filter(t => teacherHoursUsed[t.name] < t.maxHours);
                
                if (overAllocated.length === 0 || underAllocated.length === 0) break;
                
                let redistributed = false;
                
                for (const overTeacher of overAllocated) {
                    const excess = teacherHoursUsed[overTeacher.name] - overTeacher.maxHours;
                    if (excess <= 0) continue;
                    
                    for (let i = 0; i < classesToSchedule.length && teacherHoursUsed[overTeacher.name] > overTeacher.maxHours; i++) {
                        const cls = classesToSchedule[i];
                        if (cls.teacher !== overTeacher.name) continue;
                        
                        for (const underTeacher of underAllocated) {
                            if (teacherHoursUsed[underTeacher.name] >= underTeacher.maxHours) continue;
                            if (!underTeacher.subjects.includes(cls.subject)) continue;
                            
                            const classDays = getAvailableDaysForClass(cls.class);
                            const availableDays = underTeacher.days.filter(d => classDays.includes(d));
                            
                            if (availableDays.length > 0) {
                                classesToSchedule[i].teacher = underTeacher.name;
                                classesToSchedule[i].days = availableDays;
                                
                                teacherHoursUsed[overTeacher.name]--;
                                teacherHoursUsed[underTeacher.name]++;
                                
                                redistributed = true;
                                break;
                            }
                        }
                    }
                }
                
                if (!redistributed) break;
            }
            
            // Verify allocation
            output.textContent += '\n‚úÖ Classes Generated!\n';
            output.textContent += 'Teacher assignments:\n';
            
            let allPerfect = true;
            teachers.forEach(t => {
                const hours = teacherHoursUsed[t.name];
                const status = hours === t.maxHours ? '‚úÖ' : '‚ùå';
                output.textContent += `  ${status} ${t.name}: ${hours}/${t.maxHours}\n`;
                if (hours !== t.maxHours) allPerfect = false;
            });
            
            // Step 2: Create schedule
            output.textContent += '\nüìÖ Step 2: Creating Perfect Schedule...\n';
            output.textContent += '-'.repeat(70) + '\n\n';
            
            const schedule = [];
            const teacherSchedule = {};
            const classSchedule = {};
            const roomSchedule = {};
            const classDaySubjects = {};
            
            // Track restricted subjects - only 1 session allowed at any given time slot
            // (e.g., English and Maths typically have limited teachers)
            const restrictedSubjects = ['English', 'Maths'];
            const restrictedSlots = {}; // { 'English-Monday-09:00': true } means that slot is taken
            
            // Group by class
            const classesByStudent = {};
            classesToSchedule.forEach(c => {
                if (!classesByStudent[c.class]) classesByStudent[c.class] = [];
                classesByStudent[c.class].push(c);
            });
            
            // FIRST PASS: Schedule all combined sessions first (they have more constraints)
            output.textContent += 'Phase 2a: Scheduling Combined Sessions First...\n';
            const combinedSessionsToSchedule = classesToSchedule.filter(s => s.isCombined);
            
            // Track how many of each combination we've scheduled
            const scheduledCombinedCounts = {}; // { 'L3A-L3B-English': 2 } means we've scheduled 2 so far
            
            // Interleave different subjects for variety - sort so we alternate subjects
            const sortedCombinedSessions = [...combinedSessionsToSchedule].sort((a, b) => {
                // First by subject, then by group combination
                const aKey = `${a.combinedGroups.join('-')}`;
                const bKey = `${b.combinedGroups.join('-')}`;
                if (aKey !== bKey) return aKey.localeCompare(bKey);
                return a.subject.localeCompare(b.subject);
            });
            
            // Now interleave - take one of each subject in turn
            const interleaved = [];
            const bySubject = {};
            sortedCombinedSessions.forEach(s => {
                const key = `${s.combinedGroups.join('-')}-${s.subject}`;
                if (!bySubject[key]) bySubject[key] = [];
                bySubject[key].push(s);
            });
            
            const subjectKeys = Object.keys(bySubject);
            const maxLen = Math.max(...Object.values(bySubject).map(arr => arr.length));
            for (let i = 0; i < maxLen; i++) {
                for (const key of subjectKeys) {
                    if (bySubject[key][i]) {
                        interleaved.push(bySubject[key][i]);
                    }
                }
            }
            
            for (const session of interleaved) {
                const { teacher, subject, room, days, isCombined, combinedGroups, displayClass } = session;
                const comboKey = `${[...combinedGroups].sort().join('-')}-${subject}`;
                
                // Track count for this combination
                if (!scheduledCombinedCounts[comboKey]) scheduledCombinedCounts[comboKey] = 0;
                
                const primaryClass = combinedGroups[0];
                const classAvailableDays = getAvailableDaysForClass(primaryClass);
                
                // Find days that work for ALL groups in the combination
                const allGroupDays = combinedGroups.map(g => getAvailableDaysForClass(g));
                let daysToUse = classAvailableDays.filter(d => allGroupDays.every(gd => gd.includes(d)));
                if (daysToUse.length === 0) daysToUse = classAvailableDays;
                
                // For variety, try to spread across different days
                // Sort days by how many combined sessions are already on that day
                const dayCounts = {};
                daysToUse.forEach(d => {
                    dayCounts[d] = schedule.filter(s => s.isCombined && s.day === d).length;
                });
                daysToUse.sort((a, b) => dayCounts[a] - dayCounts[b]);
                
                let assigned = false;
                
                // Dynamic limit for combined English and Maths per day
                // Calculate based on: how many sessions needed vs how many common days available
                const limitedSubjects = ['English', 'Maths'];
                let maxCombinedPerDayPerSubject = 1; // Default: spread across days
                
                if (limitedSubjects.includes(subject)) {
                    // Count how many combined sessions of this subject we need for this group combo
                    const comboKeyForCount = `${[...combinedGroups].sort().join('-')}-${subject}`;
                    const totalNeeded = combinedSessionsToSchedule.filter(s => 
                        `${[...s.combinedGroups].sort().join('-')}-${s.subject}` === comboKeyForCount
                    ).length;
                    
                    // How many common days do these groups have?
                    const commonDays = daysToUse.length;
                    
                    // Calculate max per day: ceil(totalNeeded / commonDays)
                    // e.g., 4 sessions / 3 days = max 2 per day
                    // e.g., 4 sessions / 4 days = max 1 per day
                    maxCombinedPerDayPerSubject = Math.ceil(totalNeeded / commonDays);
                }
                
                for (const day of daysToUse) {
                    if (assigned) break;
                    
                    // Check if we've hit the daily limit for this subject for these groups
                    if (limitedSubjects.includes(subject)) {
                        let dayLimitReached = false;
                        for (const grp of combinedGroups) {
                            const combinedForGroupOnDay = schedule.filter(s => 
                                s.isCombined && 
                                s.day === day && 
                                s.subject === subject &&
                                s.combinedGroups && 
                                s.combinedGroups.includes(grp)
                            ).length;
                            if (combinedForGroupOnDay >= maxCombinedPerDayPerSubject) {
                                dayLimitReached = true;
                                break;
                            }
                        }
                        if (dayLimitReached) continue; // Skip this day, try next
                    }
                    
                    // Collect all valid slots with variety scores
                    const validSlots = [];
                    
                    for (const time of constraints.timeSlots) {
                        const teacherKey = `${teacher}-${day}-${time}`;
                        const roomKey = `${room}-${day}-${time}`;
                        
                        // Check restricted subjects
                        const isRestricted = restrictedSubjects.includes(subject);
                        const restrictedKey = `${subject}-${day}-${time}`;
                        const restrictedSlotTaken = isRestricted && restrictedSlots[restrictedKey];
                        
                        // Check all groups are free (THIS IS CRITICAL - checks classSchedule which is updated immediately)
                        let allGroupsFree = true;
                        for (const grp of combinedGroups) {
                            if (classSchedule[`${grp}-${day}-${time}`]) {
                                allGroupsFree = false;
                                break;
                            }
                        }
                        
                        if (!teacherSchedule[teacherKey] && 
                            !roomSchedule[roomKey] &&
                            !restrictedSlotTaken &&
                            allGroupsFree) {
                            
                            // Calculate variety score (lower = better)
                            let varietyScore = 0;
                            const timeIndex = constraints.timeSlots.indexOf(time);
                            
                            // Penalty for back-to-back same subject
                            if (timeIndex > 0) {
                                const prevTime = constraints.timeSlots[timeIndex - 1];
                                const prevSession = schedule.find(s => 
                                    s.combinedGroups && combinedGroups.some(g => s.combinedGroups.includes(g)) &&
                                    s.day === day && s.time === prevTime && s.subject === subject
                                );
                                if (prevSession) varietyScore += 200;
                            }
                            
                            // Penalty for same subject already on this day
                            const sameSubjectToday = schedule.filter(s =>
                                s.combinedGroups && combinedGroups.some(g => s.combinedGroups.includes(g)) &&
                                s.day === day && s.subject === subject
                            ).length;
                            varietyScore += sameSubjectToday * 100;
                            
                            validSlots.push({ day, time, varietyScore });
                        }
                    }
                    
                    // Pick the slot with best variety score
                    if (validSlots.length > 0) {
                        validSlots.sort((a, b) => a.varietyScore - b.varietyScore);
                        const best = validSlots[0];
                        const teacherKey = `${teacher}-${best.day}-${best.time}`;
                        const roomKey = `${room}-${best.day}-${best.time}`;
                        const isRestricted = restrictedSubjects.includes(subject);
                        const restrictedKey = `${subject}-${best.day}-${best.time}`;
                        
                        schedule.push({
                            teacher,
                            class: displayClass,
                            subject,
                            day: best.day,
                            time: best.time,
                            room,
                            isCombined: true,
                            combinedGroups: [...combinedGroups]
                        });
                        
                        teacherSchedule[teacherKey] = true;
                        roomSchedule[roomKey] = true;
                        
                        if (isRestricted) {
                            restrictedSlots[restrictedKey] = true;
                        }
                        
                        // CRITICAL: Mark ALL groups' slots as used IMMEDIATELY
                        for (const grp of combinedGroups) {
                            classSchedule[`${grp}-${best.day}-${best.time}`] = true;
                            const subKey = `${grp}-${best.day}`;
                            if (!classDaySubjects[subKey]) classDaySubjects[subKey] = [];
                            classDaySubjects[subKey].push(subject);
                        }
                        
                        scheduledCombinedCounts[comboKey]++;
                        assigned = true;
                        output.textContent += `  ‚úÖ Combined ${displayClass} ${subject} #${scheduledCombinedCounts[comboKey]}: ${best.day} ${best.time}\n`;
                    }
                }
                
                if (!assigned) {
                    output.textContent += `  ‚ùå Could not schedule combined ${displayClass} ${subject}\n`;
                    return null;
                }
            }
            
            output.textContent += '\nPhase 2b: Scheduling Regular Sessions...\n';
            
            // Group classes by faculty for staggering
            const classesByFaculty = {};
            constraints.classes.forEach(cls => {
                const config = constraints.groupConfigs[cls] || {};
                const faculty = config.faculty || 'Unknown';
                if (!classesByFaculty[faculty]) classesByFaculty[faculty] = [];
                classesByFaculty[faculty].push(cls);
            });
            
            // Process each faculty with staggering (SKIP combined sessions - already done)
            for (const [faculty, facultyClasses] of Object.entries(classesByFaculty)) {
                let staggerOffset = 0;
                
                for (const studentClass of facultyClasses) {
                    const sessions = classesByStudent[studentClass] || [];
                    
                    // Group by subject
                    const sessionsBySubject = {};
                    sessions.forEach(s => {
                        if (!sessionsBySubject[s.subject]) sessionsBySubject[s.subject] = [];
                        sessionsBySubject[s.subject].push(s);
                    });
                    
                    // Round-robin distribution
                    const allSessionsList = [];
                    const subjects = Object.keys(constraints.requirements);
                    const maxCount = Math.max(0, ...Object.values(sessionsBySubject).map(arr => arr.length));
                    
                    for (let i = 0; i < maxCount; i++) {
                        for (const subject of subjects) {
                            if (sessionsBySubject[subject] && i < sessionsBySubject[subject].length) {
                                allSessionsList.push(sessionsBySubject[subject][i]);
                            }
                        }
                    }
                    
                    // Filter out combined sessions - they were already scheduled in Phase 2a
                    const regularSessions = allSessionsList.filter(s => !s.isCombined);
                    
                    const classAvailableDays = getAvailableDaysForClass(studentClass);
                    
                    for (const session of regularSessions) {
                        const { teacher, subject, room, days, isCombined, combinedGroups, displayClass } = session;
                        
                        const validDays = days.filter(d => classAvailableDays.includes(d));
                        let daysToUse = validDays.length > 0 ? validDays : classAvailableDays;
                        
                        // For combined classes, find days that work for ALL groups
                        if (isCombined && combinedGroups) {
                            const allGroupDays = combinedGroups.map(g => getAvailableDaysForClass(g));
                            daysToUse = daysToUse.filter(d => allGroupDays.every(gd => gd.includes(d)));
                            if (daysToUse.length === 0) {
                                daysToUse = validDays.length > 0 ? validDays : classAvailableDays;
                            }
                        }
                        
                        // Sort days by subject count
                        const dayPriority = daysToUse.map(day => {
                            const key = `${studentClass}-${day}`;
                            const daySubjects = classDaySubjects[key] || [];
                            const count = daySubjects.filter(s => s === subject).length;
                            return { day, count };
                        }).sort((a, b) => a.count - b.count);
                        
                        let assigned = false;
                        
                        // Collect all valid slots with variety scores
                        const validSlots = [];
                        
                        for (const { day } of dayPriority) {
                            // Staggered time slots
                            const staggeredSlots = [
                                ...constraints.timeSlots.slice(staggerOffset),
                                ...constraints.timeSlots.slice(0, staggerOffset)
                            ];
                            
                            for (const time of staggeredSlots) {
                                const teacherKey = `${teacher}-${day}-${time}`;
                                const classKey = `${studentClass}-${day}-${time}`;
                                const roomKey = `${room}-${day}-${time}`;
                                
                                // Check if this is a restricted subject (English/Maths) and slot is already taken
                                const isRestricted = restrictedSubjects.includes(subject);
                                const restrictedKey = `${subject}-${day}-${time}`;
                                const restrictedSlotTaken = isRestricted && restrictedSlots[restrictedKey];
                                
                                // For combined classes, check all groups are free
                                let allGroupsFree = true;
                                if (isCombined && combinedGroups) {
                                    for (const grp of combinedGroups) {
                                        if (classSchedule[`${grp}-${day}-${time}`]) {
                                            allGroupsFree = false;
                                            break;
                                        }
                                    }
                                }
                                
                                if (!teacherSchedule[teacherKey] && 
                                    !classSchedule[classKey] && 
                                    !roomSchedule[roomKey] &&
                                    !restrictedSlotTaken &&
                                    allGroupsFree) {
                                    
                                    // Calculate variety score (lower = better)
                                    let varietyScore = 0;
                                    const timeIndex = constraints.timeSlots.indexOf(time);
                                    
                                    // Penalty for back-to-back same subject
                                    if (timeIndex > 0) {
                                        const prevTime = constraints.timeSlots[timeIndex - 1];
                                        const prevSession = schedule.find(s => 
                                            s.class === studentClass &&
                                            s.day === day && s.time === prevTime && s.subject === subject
                                        );
                                        if (prevSession) varietyScore += 200;
                                    }
                                    if (timeIndex < constraints.timeSlots.length - 1) {
                                        const nextTime = constraints.timeSlots[timeIndex + 1];
                                        const nextSession = schedule.find(s => 
                                            s.class === studentClass &&
                                            s.day === day && s.time === nextTime && s.subject === subject
                                        );
                                        if (nextSession) varietyScore += 200;
                                    }
                                    
                                    // Penalty for same subject already on this day
                                    const sameSubjectToday = schedule.filter(s =>
                                        s.class === studentClass &&
                                        s.day === day && s.subject === subject
                                    ).length;
                                    varietyScore += sameSubjectToday * 100;
                                    
                                    validSlots.push({ day, time, varietyScore, isRestricted, restrictedKey });
                                }
                            }
                        }
                        
                        // Pick the slot with best variety score
                        if (validSlots.length > 0) {
                            validSlots.sort((a, b) => a.varietyScore - b.varietyScore);
                            const best = validSlots[0];
                            
                            const teacherKey = `${teacher}-${best.day}-${best.time}`;
                            const classKey = `${studentClass}-${best.day}-${best.time}`;
                            const roomKey = `${room}-${best.day}-${best.time}`;
                            
                            const scheduleEntry = {
                                teacher,
                                class: isCombined ? displayClass : studentClass,
                                subject,
                                day: best.day,
                                time: best.time,
                                room,
                                isCombined: isCombined || false
                            };
                            
                            if (isCombined) {
                                scheduleEntry.combinedGroups = combinedGroups;
                            }
                            
                            schedule.push(scheduleEntry);
                            
                            teacherSchedule[teacherKey] = true;
                            classSchedule[classKey] = true;
                            roomSchedule[roomKey] = true;
                            
                            // Mark restricted subject slot as taken
                            if (best.isRestricted) {
                                restrictedSlots[best.restrictedKey] = true;
                            }
                            
                            // For combined classes, mark ALL groups' slots as used
                            if (isCombined && combinedGroups) {
                                for (const grp of combinedGroups) {
                                    classSchedule[`${grp}-${best.day}-${best.time}`] = true;
                                    const subKey = `${grp}-${best.day}`;
                                    if (!classDaySubjects[subKey]) classDaySubjects[subKey] = [];
                                    classDaySubjects[subKey].push(subject);
                                }
                            }
                            
                            const subjectKey = `${studentClass}-${best.day}`;
                            if (!classDaySubjects[subjectKey]) classDaySubjects[subjectKey] = [];
                            classDaySubjects[subjectKey].push(subject);
                            
                            assigned = true;
                        }
                        
                        if (!assigned) {
                            output.textContent += `  ‚ùå Could not assign ${subject} for ${studentClass}${isCombined ? ' (combined)' : ''}\n`;
                            return null;
                        }
                    }
                    
                    staggerOffset = (staggerOffset + 1) % constraints.timeSlots.length;
                }
            }
            
            // Step 3: Add Work Placement sessions for T-Level groups (FULL DAY)
            output.textContent += '\nüíº Step 3: Adding Work Placement Days (T-Levels)...\n';
            output.textContent += '-'.repeat(70) + '\n\n';
            
            let workPlacementCount = 0;
            let workPlacementSessions = 0;
            
            for (const studentClass of constraints.classes) {
                const config = constraints.groupConfigs[studentClass] || {};
                
                if (config.workPlacement && config.workPlacementDay) {
                    const wpDay = config.workPlacementDay;
                    let sessionsAdded = 0;
                    const totalSlots = constraints.timeSlots.length;
                    
                    output.textContent += `  ${studentClass}: Adding ${totalSlots} Work Placement sessions on ${wpDay}...\n`;
                    
                    // Add ALL time slots on the work placement day (full day of industry placement)
                    for (let slotIdx = 0; slotIdx < constraints.timeSlots.length; slotIdx++) {
                        const time = constraints.timeSlots[slotIdx];
                        const classKey = `${studentClass}-${wpDay}-${time}`;
                        
                        // Check if already scheduled
                        if (classSchedule[classKey]) {
                            output.textContent += `    ‚ö†Ô∏è Slot ${time} already occupied\n`;
                        } else {
                            schedule.push({
                                teacher: 'Industry Placement',
                                class: studentClass,
                                subject: 'Work Placement',
                                day: wpDay,
                                time: time,
                                room: 'Employer Site',
                                isWorkPlacement: true
                            });
                            
                            classSchedule[classKey] = true;
                            sessionsAdded++;
                            workPlacementSessions++;
                        }
                    }
                    
                    if (sessionsAdded === totalSlots) {
                        output.textContent += `    ‚úÖ Full day scheduled (${sessionsAdded}/${totalSlots} sessions)\n`;
                        workPlacementCount++;
                    } else if (sessionsAdded > 0) {
                        output.textContent += `    ‚ö†Ô∏è Partial day (${sessionsAdded}/${totalSlots} sessions)\n`;
                        workPlacementCount++;
                    } else {
                        output.textContent += `    ‚ùå Could not schedule any sessions\n`;
                    }
                }
            }
            
            if (workPlacementCount === 0) {
                output.textContent += '  No T-Level work placements configured\n';
            } else {
                output.textContent += `\n  Total: ${workPlacementCount} groups with Work Placement (${workPlacementSessions} sessions)\n`;
            }
            
            output.textContent += `\n‚úÖ Schedule created: ${schedule.length} assignments\n`;
            
            return schedule;
        }

        // ==================== BACKTRACKING ALGORITHM ====================
        function runBacktrackingScheduler() {
            const output = document.getElementById('scheduleOutput');
            output.textContent += 'üîÑ BACKTRACKING ALGORITHM\n';
            output.textContent += 'Systematically trying all possibilities with intelligent pruning...\n\n';
            
            const startTime = performance.now();
            
            // Build list of all sessions that need to be scheduled
            const sessionsToSchedule = [];
            const combinedClasses = constraints.combinedClasses || [];
            const combinedSessionsMap = buildCombinedSessionsMap(combinedClasses);
            
            for (const className of constraints.classes) {
                for (const [subject, count] of Object.entries(constraints.requirements)) {
                    const comboKey = `${className}-${subject}`;
                    const comboInfo = combinedSessionsMap[comboKey];
                    
                    let effectiveCount = count;
                    if (comboInfo && !comboInfo.isPrimary) {
                        effectiveCount = Math.max(0, count - comboInfo.reducedBy);
                    }
                    
                    for (let i = 0; i < effectiveCount; i++) {
                        const isCombined = comboInfo && comboInfo.isPrimary && i < (comboInfo.combinedSessions || 0);
                        sessionsToSchedule.push({
                            class: className,
                            subject: subject,
                            isCombined: isCombined,
                            combinedGroups: isCombined ? [className, ...comboInfo.combineWith] : null
                        });
                    }
                }
            }
            
            output.textContent += `Sessions to schedule: ${sessionsToSchedule.length}\n`;
            
            // Get all possible slots
            const allSlots = [];
            for (const day of constraints.days) {
                for (const time of constraints.timeSlots) {
                    allSlots.push({ day, time });
                }
            }
            
            // State tracking
            const schedule = [];
            const teacherSchedule = {};
            const classSchedule = {};
            const roomSchedule = {};
            const restrictedSlots = {};
            const restrictedSubjects = ['English', 'Maths'];
            
            let backtracks = 0;
            let attempts = 0;
            const maxAttempts = 100000;
            
            // Recursive backtracking function
            function backtrack(sessionIndex) {
                attempts++;
                if (attempts > maxAttempts) return false;
                
                if (sessionIndex >= sessionsToSchedule.length) {
                    return true; // All sessions scheduled!
                }
                
                const session = sessionsToSchedule[sessionIndex];
                const availableDays = getAvailableDaysForClass(session.class);
                
                // Get teachers for this subject
                const eligibleTeachers = teachers.filter(t => t.subjects.includes(session.subject));
                
                // Try each combination of teacher, day, time, room
                for (const teacher of eligibleTeachers) {
                    for (const day of availableDays) {
                        if (!teacher.days.includes(day)) continue;
                        
                        // For combined classes, check all groups available this day
                        if (session.isCombined) {
                            const allAvailable = session.combinedGroups.every(g => 
                                getAvailableDaysForClass(g).includes(day)
                            );
                            if (!allAvailable) continue;
                        }
                        
                        for (const time of constraints.timeSlots) {
                            const teacherKey = `${teacher.name}-${day}-${time}`;
                            if (teacherSchedule[teacherKey]) continue;
                            
                            // Check class availability
                            const classKey = `${session.class}-${day}-${time}`;
                            if (classSchedule[classKey]) continue;
                            
                            // For combined, check all groups free
                            if (session.isCombined) {
                                let anyBusy = false;
                                for (const g of session.combinedGroups) {
                                    if (classSchedule[`${g}-${day}-${time}`]) {
                                        anyBusy = true;
                                        break;
                                    }
                                }
                                if (anyBusy) continue;
                            }
                            
                            // Check restricted subjects
                            if (restrictedSubjects.includes(session.subject)) {
                                const restrictedKey = `${session.subject}-${day}-${time}`;
                                if (restrictedSlots[restrictedKey]) continue;
                            }
                            
                            for (const room of constraints.rooms) {
                                const roomKey = `${room}-${day}-${time}`;
                                if (roomSchedule[roomKey]) continue;
                                
                                // Try this assignment
                                const entry = {
                                    teacher: teacher.name,
                                    class: session.isCombined ? session.combinedGroups.join(' + ') : session.class,
                                    subject: session.subject,
                                    day, time, room,
                                    isCombined: session.isCombined || false,
                                    combinedGroups: session.combinedGroups
                                };
                                
                                // Make assignment
                                schedule.push(entry);
                                teacherSchedule[teacherKey] = true;
                                classSchedule[classKey] = true;
                                roomSchedule[roomKey] = true;
                                
                                if (session.isCombined) {
                                    for (const g of session.combinedGroups) {
                                        classSchedule[`${g}-${day}-${time}`] = true;
                                    }
                                }
                                
                                if (restrictedSubjects.includes(session.subject)) {
                                    restrictedSlots[`${session.subject}-${day}-${time}`] = true;
                                }
                                
                                // Recurse
                                if (backtrack(sessionIndex + 1)) {
                                    return true;
                                }
                                
                                // Backtrack - undo assignment
                                backtracks++;
                                schedule.pop();
                                delete teacherSchedule[teacherKey];
                                delete classSchedule[classKey];
                                delete roomSchedule[roomKey];
                                
                                if (session.isCombined) {
                                    for (const g of session.combinedGroups) {
                                        delete classSchedule[`${g}-${day}-${time}`];
                                    }
                                }
                                
                                if (restrictedSubjects.includes(session.subject)) {
                                    delete restrictedSlots[`${session.subject}-${day}-${time}`];
                                }
                            }
                        }
                    }
                }
                
                return false; // No valid assignment found
            }
            
            // Sort sessions - harder constraints first (combined, restricted subjects)
            sessionsToSchedule.sort((a, b) => {
                if (a.isCombined && !b.isCombined) return -1;
                if (!a.isCombined && b.isCombined) return 1;
                if (restrictedSubjects.includes(a.subject) && !restrictedSubjects.includes(b.subject)) return -1;
                if (!restrictedSubjects.includes(a.subject) && restrictedSubjects.includes(b.subject)) return 1;
                return 0;
            });
            
            const success = backtrack(0);
            const endTime = performance.now();
            
            output.textContent += `\nAttempts: ${attempts.toLocaleString()}\n`;
            output.textContent += `Backtracks: ${backtracks.toLocaleString()}\n`;
            output.textContent += `Time: ${(endTime - startTime).toFixed(0)}ms\n`;
            
            if (success) {
                output.textContent += `\n‚úÖ Solution found with ${schedule.length} assignments\n`;
                return schedule;
            } else {
                output.textContent += `\n‚ùå No solution found within ${maxAttempts.toLocaleString()} attempts\n`;
                return null;
            }
        }

        // ==================== SAT SOLVER ALGORITHM ====================
        function runSATScheduler() {
            const output = document.getElementById('scheduleOutput');
            output.textContent += 'üßÆ SAT SOLVER ALGORITHM\n';
            output.textContent += 'Converting to Boolean satisfiability problem...\n\n';
            
            const startTime = performance.now();
            
            // Build sessions list
            const sessionsToSchedule = [];
            const combinedClasses = constraints.combinedClasses || [];
            const combinedSessionsMap = buildCombinedSessionsMap(combinedClasses);
            
            for (const className of constraints.classes) {
                for (const [subject, count] of Object.entries(constraints.requirements)) {
                    const comboKey = `${className}-${subject}`;
                    const comboInfo = combinedSessionsMap[comboKey];
                    
                    let effectiveCount = count;
                    if (comboInfo && !comboInfo.isPrimary) {
                        effectiveCount = Math.max(0, count - comboInfo.reducedBy);
                    }
                    
                    for (let i = 0; i < effectiveCount; i++) {
                        const isCombined = comboInfo && comboInfo.isPrimary && i < (comboInfo.combinedSessions || 0);
                        sessionsToSchedule.push({
                            id: sessionsToSchedule.length,
                            class: className,
                            subject: subject,
                            isCombined: isCombined,
                            combinedGroups: isCombined ? [className, ...comboInfo.combineWith] : null
                        });
                    }
                }
            }
            
            // SAT variables: X[session][teacher][day][time][room] = true/false
            // We'll use a simpler encoding with constraint propagation (DPLL-lite)
            
            const allSlots = [];
            for (const day of constraints.days) {
                for (const time of constraints.timeSlots) {
                    for (const room of constraints.rooms) {
                        allSlots.push({ day, time, room });
                    }
                }
            }
            
            // For each session, compute valid assignments
            const restrictedSubjects = ['English', 'Maths'];
            const sessionDomains = sessionsToSchedule.map(session => {
                const domain = [];
                const availableDays = getAvailableDaysForClass(session.class);
                const eligibleTeachers = teachers.filter(t => t.subjects.includes(session.subject));
                
                for (const teacher of eligibleTeachers) {
                    for (const day of availableDays) {
                        if (!teacher.days.includes(day)) continue;
                        
                        if (session.isCombined) {
                            const allAvailable = session.combinedGroups.every(g => 
                                getAvailableDaysForClass(g).includes(day)
                            );
                            if (!allAvailable) continue;
                        }
                        
                        for (const time of constraints.timeSlots) {
                            for (const room of constraints.rooms) {
                                domain.push({
                                    teacher: teacher.name,
                                    day, time, room
                                });
                            }
                        }
                    }
                }
                return domain;
            });
            
            output.textContent += `Sessions: ${sessionsToSchedule.length}\n`;
            output.textContent += `Average domain size: ${Math.round(sessionDomains.reduce((a,d) => a + d.length, 0) / sessionDomains.length)}\n\n`;
            
            // DPLL-style solving with unit propagation
            const schedule = [];
            const teacherSchedule = {};
            const classSchedule = {};
            const roomSchedule = {};
            const restrictedSlots = {};
            
            let propagations = 0;
            let decisions = 0;
            
            function isConsistent(session, assignment) {
                const { teacher, day, time, room } = assignment;
                
                // Teacher conflict
                if (teacherSchedule[`${teacher}-${day}-${time}`]) return false;
                
                // Room conflict
                if (roomSchedule[`${room}-${day}-${time}`]) return false;
                
                // Class conflict
                if (classSchedule[`${session.class}-${day}-${time}`]) return false;
                
                // Combined class conflicts
                if (session.isCombined) {
                    for (const g of session.combinedGroups) {
                        if (classSchedule[`${g}-${day}-${time}`]) return false;
                    }
                }
                
                // Restricted subject conflict
                if (restrictedSubjects.includes(session.subject)) {
                    if (restrictedSlots[`${session.subject}-${day}-${time}`]) return false;
                }
                
                return true;
            }
            
            function propagate() {
                let changed = true;
                while (changed) {
                    changed = false;
                    propagations++;
                    
                    for (let i = 0; i < sessionsToSchedule.length; i++) {
                        if (schedule[i]) continue; // Already assigned
                        
                        // Filter domain to consistent values
                        sessionDomains[i] = sessionDomains[i].filter(a => 
                            isConsistent(sessionsToSchedule[i], a)
                        );
                        
                        // Empty domain = failure
                        if (sessionDomains[i].length === 0) return false;
                        
                        // Unit propagation: only one choice left
                        if (sessionDomains[i].length === 1) {
                            const assignment = sessionDomains[i][0];
                            schedule[i] = {
                                ...assignment,
                                class: sessionsToSchedule[i].isCombined ? 
                                    sessionsToSchedule[i].combinedGroups.join(' + ') : 
                                    sessionsToSchedule[i].class,
                                subject: sessionsToSchedule[i].subject,
                                isCombined: sessionsToSchedule[i].isCombined,
                                combinedGroups: sessionsToSchedule[i].combinedGroups
                            };
                            
                            // Update constraints
                            teacherSchedule[`${assignment.teacher}-${assignment.day}-${assignment.time}`] = true;
                            roomSchedule[`${assignment.room}-${assignment.day}-${assignment.time}`] = true;
                            classSchedule[`${sessionsToSchedule[i].class}-${assignment.day}-${assignment.time}`] = true;
                            
                            if (sessionsToSchedule[i].isCombined) {
                                for (const g of sessionsToSchedule[i].combinedGroups) {
                                    classSchedule[`${g}-${assignment.day}-${assignment.time}`] = true;
                                }
                            }
                            
                            if (restrictedSubjects.includes(sessionsToSchedule[i].subject)) {
                                restrictedSlots[`${sessionsToSchedule[i].subject}-${assignment.day}-${assignment.time}`] = true;
                            }
                            
                            changed = true;
                        }
                    }
                }
                return true;
            }
            
            function solve() {
                if (!propagate()) return false;
                
                // Check if complete
                const unassigned = schedule.findIndex((s, i) => !s);
                if (unassigned === -1) return true;
                
                // Choose variable with smallest domain (MRV heuristic)
                let minIdx = -1;
                let minSize = Infinity;
                for (let i = 0; i < sessionsToSchedule.length; i++) {
                    if (!schedule[i] && sessionDomains[i].length < minSize) {
                        minSize = sessionDomains[i].length;
                        minIdx = i;
                    }
                }
                
                if (minIdx === -1 || minSize === 0) return false;
                
                decisions++;
                
                // Try each value in domain
                const savedDomains = sessionDomains.map(d => [...d]);
                const savedSchedule = [...schedule];
                const savedTeacher = {...teacherSchedule};
                const savedClass = {...classSchedule};
                const savedRoom = {...roomSchedule};
                const savedRestricted = {...restrictedSlots};
                
                for (const assignment of sessionDomains[minIdx]) {
                    // Make assignment
                    schedule[minIdx] = {
                        ...assignment,
                        class: sessionsToSchedule[minIdx].isCombined ? 
                            sessionsToSchedule[minIdx].combinedGroups.join(' + ') : 
                            sessionsToSchedule[minIdx].class,
                        subject: sessionsToSchedule[minIdx].subject,
                        isCombined: sessionsToSchedule[minIdx].isCombined,
                        combinedGroups: sessionsToSchedule[minIdx].combinedGroups
                    };
                    
                    teacherSchedule[`${assignment.teacher}-${assignment.day}-${assignment.time}`] = true;
                    roomSchedule[`${assignment.room}-${assignment.day}-${assignment.time}`] = true;
                    classSchedule[`${sessionsToSchedule[minIdx].class}-${assignment.day}-${assignment.time}`] = true;
                    
                    if (sessionsToSchedule[minIdx].isCombined) {
                        for (const g of sessionsToSchedule[minIdx].combinedGroups) {
                            classSchedule[`${g}-${assignment.day}-${assignment.time}`] = true;
                        }
                    }
                    
                    if (restrictedSubjects.includes(sessionsToSchedule[minIdx].subject)) {
                        restrictedSlots[`${sessionsToSchedule[minIdx].subject}-${assignment.day}-${assignment.time}`] = true;
                    }
                    
                    if (solve()) return true;
                    
                    // Restore state
                    for (let i = 0; i < sessionDomains.length; i++) {
                        sessionDomains[i] = savedDomains[i];
                    }
                    for (let i = 0; i < schedule.length; i++) {
                        schedule[i] = savedSchedule[i];
                    }
                    Object.keys(teacherSchedule).forEach(k => delete teacherSchedule[k]);
                    Object.assign(teacherSchedule, savedTeacher);
                    Object.keys(classSchedule).forEach(k => delete classSchedule[k]);
                    Object.assign(classSchedule, savedClass);
                    Object.keys(roomSchedule).forEach(k => delete roomSchedule[k]);
                    Object.assign(roomSchedule, savedRoom);
                    Object.keys(restrictedSlots).forEach(k => delete restrictedSlots[k]);
                    Object.assign(restrictedSlots, savedRestricted);
                }
                
                return false;
            }
            
            // Sort sessions by constraint difficulty
            const sortedIndices = sessionsToSchedule.map((s, i) => i);
            sortedIndices.sort((a, b) => {
                const sa = sessionsToSchedule[a];
                const sb = sessionsToSchedule[b];
                if (sa.isCombined && !sb.isCombined) return -1;
                if (!sa.isCombined && sb.isCombined) return 1;
                return sessionDomains[a].length - sessionDomains[b].length;
            });
            
            const success = solve();
            const endTime = performance.now();
            
            output.textContent += `Propagations: ${propagations.toLocaleString()}\n`;
            output.textContent += `Decisions: ${decisions.toLocaleString()}\n`;
            output.textContent += `Time: ${(endTime - startTime).toFixed(0)}ms\n`;
            
            if (success) {
                const result = schedule.filter(s => s);
                output.textContent += `\n‚úÖ SAT solution found with ${result.length} assignments\n`;
                return result;
            } else {
                output.textContent += `\n‚ùå No satisfying assignment exists (UNSAT)\n`;
                return null;
            }
        }

        // ==================== INTEGER LINEAR PROGRAMMING ALGORITHM ====================
        function runILPScheduler() {
            const output = document.getElementById('scheduleOutput');
            output.textContent += 'üìä INTEGER LINEAR PROGRAMMING ALGORITHM\n';
            output.textContent += 'Optimizing for variety and spread...\n\n';
            
            const startTime = performance.now();
            
            // Build sessions list
            const sessionsToSchedule = [];
            const combinedClasses = constraints.combinedClasses || [];
            const combinedSessionsMap = buildCombinedSessionsMap(combinedClasses);
            
            output.textContent += `üìù Session Generation (combined classes debug):\n`;
            
            for (const className of constraints.classes) {
                for (const [subject, count] of Object.entries(constraints.requirements)) {
                    const comboKey = `${className}-${subject}`;
                    const comboInfo = combinedSessionsMap[comboKey];
                    
                    let effectiveCount = count;
                    if (comboInfo && !comboInfo.isPrimary) {
                        // Secondary in combined group - reduce count
                        effectiveCount = Math.max(0, count - comboInfo.reducedBy);
                    }
                    
                    // Debug output for combined subjects
                    if (comboInfo) {
                        if (comboInfo.isPrimary) {
                            output.textContent += `  ${className} ${subject}: ${effectiveCount} sessions (${comboInfo.combinedSessions} combined with ${comboInfo.combineWith.join('+')})\n`;
                        } else {
                            output.textContent += `  ${className} ${subject}: ${effectiveCount} sessions (skipped ${comboInfo.reducedBy} - handled by combined)\n`;
                        }
                    }
                    
                    for (let i = 0; i < effectiveCount; i++) {
                        const isCombined = comboInfo && comboInfo.isPrimary && i < (comboInfo.combinedSessions || 0);
                        sessionsToSchedule.push({
                            id: sessionsToSchedule.length,
                            class: className,
                            subject: subject,
                            isCombined: isCombined,
                            combinedGroups: isCombined ? [className, ...comboInfo.combineWith] : null
                        });
                    }
                }
            }
            
            output.textContent += `\n`;
            
            const restrictedSubjects = ['English', 'Maths'];
            
            // Schedule sessions in order of difficulty (most constrained first)
            // But interleave by class to spread the work
            const sessionsByClass = {};
            sessionsToSchedule.forEach(s => {
                const key = s.class;
                if (!sessionsByClass[key]) sessionsByClass[key] = [];
                sessionsByClass[key].push(s);
            });
            
            // Interleave sessions from different classes
            const orderedSessions = [];
            const classKeys = Object.keys(sessionsByClass);
            const maxSessions = Math.max(...Object.values(sessionsByClass).map(arr => arr.length));
            
            for (let i = 0; i < maxSessions; i++) {
                for (const key of classKeys) {
                    if (sessionsByClass[key][i]) {
                        orderedSessions.push(sessionsByClass[key][i]);
                    }
                }
            }
            
            // Sort combined sessions first (more constrained)
            orderedSessions.sort((a, b) => {
                if (a.isCombined && !b.isCombined) return -1;
                if (!a.isCombined && b.isCombined) return 1;
                if (restrictedSubjects.includes(a.subject) && !restrictedSubjects.includes(b.subject)) return -1;
                if (!restrictedSubjects.includes(a.subject) && restrictedSubjects.includes(b.subject)) return 1;
                return 0;
            });
            
            output.textContent += `Sessions: ${sessionsToSchedule.length}\n`;
            output.textContent += `Classes: ${classKeys.length}\n`;
            
            // PRE-FLIGHT CAPACITY CHECK
            output.textContent += `\nüìã Pre-flight Capacity Check:\n`;
            let capacityOk = true;
            const classSessionCounts = {};
            
            // Count sessions per class (including combined)
            for (const session of sessionsToSchedule) {
                if (session.isCombined && session.combinedGroups) {
                    for (const g of session.combinedGroups) {
                        classSessionCounts[g] = (classSessionCounts[g] || 0) + 1;
                    }
                } else {
                    classSessionCounts[session.class] = (classSessionCounts[session.class] || 0) + 1;
                }
            }
            
            for (const className of constraints.classes) {
                const availableDays = getAvailableDaysForClass(className);
                const availableSlots = availableDays.length * constraints.timeSlots.length;
                const sessionsNeeded = classSessionCounts[className] || 0;
                const status = sessionsNeeded <= availableSlots ? '‚úÖ' : '‚ùå';
                
                if (sessionsNeeded > availableSlots) capacityOk = false;
                
                output.textContent += `  ${status} ${className}: ${sessionsNeeded} sessions, ${availableSlots} slots (${availableDays.length} days √ó ${constraints.timeSlots.length} periods)\n`;
            }
            
            if (!capacityOk) {
                output.textContent += `\n‚ö†Ô∏è WARNING: Some classes have more sessions than available slots!\n`;
                output.textContent += `   Solutions:\n`;
                output.textContent += `   ‚Ä¢ Reduce subject hours in Configure Constraints\n`;
                output.textContent += `   ‚Ä¢ Remove days off for some groups\n`;
                output.textContent += `   ‚Ä¢ Check combined classes aren't creating duplicates\n\n`;
            }
            
            output.textContent += `\nOptimizing for variety...\n\n`;
            
            // Try scheduling with ability to retry on failure
            function attemptSchedule(relaxVariety = false) {
                // Reset state
                const schedule = [];
                const teacherSchedule = {};
                const classSchedule = {};
                const roomSchedule = {};
                const restrictedSlots = {};
                const classSubjectDayCount = {};
                const classDayCount = {};
                
                let totalVarietyCost = 0;
                
                // Helper to calculate variety cost (can be relaxed)
                function calcVarietyCost(session, assignment) {
                    if (relaxVariety) return 0; // Skip variety optimization on retry
                    
                    const { day, time } = assignment;
                    const classKey = session.isCombined ? session.combinedGroups[0] : session.class;
                    let cost = 0;
                    
                    const subjectDayKey = `${classKey}-${session.subject}-${day}`;
                    const subjectDayCount = classSubjectDayCount[subjectDayKey] || 0;
                    cost += subjectDayCount * 100;
                    
                    const dayKey = `${classKey}-${day}`;
                    const dayCount = classDayCount[dayKey] || 0;
                    const idealPerDay = Math.ceil(Object.values(constraints.requirements).reduce((a,b) => a+b, 0) / constraints.days.length);
                    if (dayCount >= idealPerDay) {
                        cost += (dayCount - idealPerDay + 1) * 50;
                    }
                    
                    const timeIndex = constraints.timeSlots.indexOf(time);
                    if (timeIndex > 0) {
                        const prevTime = constraints.timeSlots[timeIndex - 1];
                        const prevSession = schedule.find(s => 
                            (s.class === classKey || (s.combinedGroups && s.combinedGroups.includes(classKey))) &&
                            s.day === day && s.time === prevTime && s.subject === session.subject
                        );
                        if (prevSession) cost += 200;
                    }
                    
                    if (session.isCombined) {
                        const combinedOnDay = schedule.filter(s => 
                            s.isCombined && s.day === day &&
                            s.combinedGroups && session.combinedGroups.some(g => s.combinedGroups.includes(g))
                        ).length;
                        cost += combinedOnDay * 80;
                    }
                    
                    cost += timeIndex * 2;
                    return cost;
                }
                
                // Helper to check validity
                function isValid(session, assignment) {
                    const { teacher, day, time, room } = assignment;
                    
                    if (teacherSchedule[`${teacher}-${day}-${time}`]) return false;
                    if (roomSchedule[`${room}-${day}-${time}`]) return false;
                    if (classSchedule[`${session.class}-${day}-${time}`]) return false;
                    
                    if (session.isCombined) {
                        for (const g of session.combinedGroups) {
                            if (classSchedule[`${g}-${day}-${time}`]) return false;
                        }
                    }
                    
                    if (restrictedSubjects.includes(session.subject)) {
                        if (restrictedSlots[`${session.subject}-${day}-${time}`]) return false;
                    }
                    
                    return true;
                }
                
                // Get valid assignments
                function getValid(session) {
                    const valid = [];
                    const availableDays = getAvailableDaysForClass(session.class);
                    const eligibleTeachers = teachers.filter(t => t.subjects.includes(session.subject));
                    
                    for (const teacher of eligibleTeachers) {
                        for (const day of availableDays) {
                            if (!teacher.days.includes(day)) continue;
                            
                            if (session.isCombined) {
                                const allAvailable = session.combinedGroups.every(g => 
                                    getAvailableDaysForClass(g).includes(day)
                                );
                                if (!allAvailable) continue;
                            }
                            
                            for (const time of constraints.timeSlots) {
                                for (const room of constraints.rooms) {
                                    const assignment = { teacher, day, time, room };
                                    if (isValid(session, assignment)) {
                                        assignment.varietyCost = calcVarietyCost(session, assignment);
                                        valid.push(assignment);
                                    }
                                }
                            }
                        }
                    }
                    
                    return valid;
                }
                
                for (const session of orderedSessions) {
                    const validAssignments = getValid(session);
                    
                    if (validAssignments.length === 0) {
                        // Collect debug info about why there are no valid slots
                        const debugInfo = {
                            teacherConflicts: 0,
                            roomConflicts: 0,
                            classConflicts: 0,
                            restrictedConflicts: 0,
                            combinedConflicts: 0,
                            noTeacherDays: 0,
                            totalChecked: 0
                        };
                        
                        const availableDays = getAvailableDaysForClass(session.class);
                        const eligibleTeachers = teachers.filter(t => t.subjects.includes(session.subject));
                        
                        for (const teacher of eligibleTeachers) {
                            for (const day of availableDays) {
                                if (!teacher.days.includes(day)) {
                                    debugInfo.noTeacherDays++;
                                    continue;
                                }
                                
                                if (session.isCombined) {
                                    const allAvailable = session.combinedGroups.every(g => 
                                        getAvailableDaysForClass(g).includes(day)
                                    );
                                    if (!allAvailable) {
                                        debugInfo.combinedConflicts++;
                                        continue;
                                    }
                                }
                                
                                for (const time of constraints.timeSlots) {
                                    for (const room of constraints.rooms) {
                                        debugInfo.totalChecked++;
                                        
                                        if (teacherSchedule[`${teacher.name}-${day}-${time}`]) {
                                            debugInfo.teacherConflicts++;
                                        } else if (roomSchedule[`${room}-${day}-${time}`]) {
                                            debugInfo.roomConflicts++;
                                        } else if (classSchedule[`${session.class}-${day}-${time}`]) {
                                            debugInfo.classConflicts++;
                                        } else if (session.isCombined && session.combinedGroups.some(g => classSchedule[`${g}-${day}-${time}`])) {
                                            debugInfo.combinedConflicts++;
                                        } else if (restrictedSubjects.includes(session.subject) && restrictedSlots[`${session.subject}-${day}-${time}`]) {
                                            debugInfo.restrictedConflicts++;
                                        }
                                    }
                                }
                            }
                        }
                        
                        return { success: false, failedSession: session, schedule: null, debugInfo };
                    }
                    
                    validAssignments.sort((a, b) => a.varietyCost - b.varietyCost);
                    const chosen = validAssignments[0];
                    totalVarietyCost += chosen.varietyCost;
                    
                    const entry = {
                        teacher: chosen.teacher,
                        class: session.isCombined ? session.combinedGroups.join(' + ') : session.class,
                        subject: session.subject,
                        day: chosen.day,
                        time: chosen.time,
                        room: chosen.room,
                        isCombined: session.isCombined || false,
                        combinedGroups: session.combinedGroups
                    };
                    
                    schedule.push(entry);
                    
                    teacherSchedule[`${chosen.teacher}-${chosen.day}-${chosen.time}`] = true;
                    roomSchedule[`${chosen.room}-${chosen.day}-${chosen.time}`] = true;
                    classSchedule[`${session.class}-${chosen.day}-${chosen.time}`] = true;
                    
                    const classKey = session.isCombined ? session.combinedGroups[0] : session.class;
                    const subjectDayKey = `${classKey}-${session.subject}-${chosen.day}`;
                    classSubjectDayCount[subjectDayKey] = (classSubjectDayCount[subjectDayKey] || 0) + 1;
                    
                    const dayKey = `${classKey}-${chosen.day}`;
                    classDayCount[dayKey] = (classDayCount[dayKey] || 0) + 1;
                    
                    if (session.isCombined) {
                        for (const g of session.combinedGroups) {
                            classSchedule[`${g}-${chosen.day}-${chosen.time}`] = true;
                            classSubjectDayCount[`${g}-${session.subject}-${chosen.day}`] = 
                                (classSubjectDayCount[`${g}-${session.subject}-${chosen.day}`] || 0) + 1;
                            classDayCount[`${g}-${chosen.day}`] = (classDayCount[`${g}-${chosen.day}`] || 0) + 1;
                        }
                    }
                    
                    if (restrictedSubjects.includes(session.subject)) {
                        restrictedSlots[`${session.subject}-${chosen.day}-${chosen.time}`] = true;
                    }
                }
                
                return { success: true, schedule, totalVarietyCost };
            }
            
            // First attempt with variety optimization
            let result = attemptSchedule(false);
            
            if (!result.success) {
                output.textContent += `‚ö†Ô∏è Failed with variety optimization on: ${result.failedSession.class} ${result.failedSession.subject}\n`;
                output.textContent += `Retrying without variety constraints...\n\n`;
                
                // Retry without variety optimization
                result = attemptSchedule(true);
                
                if (!result.success) {
                    // Debug: show what slots are available
                    const session = result.failedSession;
                    const debug = result.debugInfo || {};
                    
                    output.textContent += `\nüîç Debug for ${session.class} ${session.subject}:\n`;
                    
                    const availableDays = getAvailableDaysForClass(session.class);
                    output.textContent += `  Available days: ${availableDays.join(', ')}\n`;
                    
                    const eligibleTeachers = teachers.filter(t => t.subjects.includes(session.subject));
                    output.textContent += `  Eligible teachers: ${eligibleTeachers.map(t => t.name).join(', ') || 'NONE'}\n`;
                    
                    if (eligibleTeachers.length === 0) {
                        output.textContent += `  ‚ùå No teacher can teach ${session.subject}!\n`;
                    } else if (debug.totalChecked > 0) {
                        output.textContent += `\n  üìä Conflict Analysis (${debug.totalChecked} slot combinations checked):\n`;
                        output.textContent += `    ‚Ä¢ Teacher busy: ${debug.teacherConflicts || 0}\n`;
                        output.textContent += `    ‚Ä¢ Room busy: ${debug.roomConflicts || 0}\n`;
                        output.textContent += `    ‚Ä¢ Class busy: ${debug.classConflicts || 0}\n`;
                        output.textContent += `    ‚Ä¢ Restricted subject (Eng/Maths): ${debug.restrictedConflicts || 0}\n`;
                        output.textContent += `    ‚Ä¢ Combined group conflict: ${debug.combinedConflicts || 0}\n`;
                        output.textContent += `    ‚Ä¢ Teacher not available that day: ${debug.noTeacherDays || 0}\n`;
                        
                        // Calculate capacity
                        const totalSlots = availableDays.length * constraints.timeSlots.length;
                        output.textContent += `\n  üìà Capacity Check:\n`;
                        output.textContent += `    ‚Ä¢ Total time slots per class: ${totalSlots}\n`;
                        output.textContent += `    ‚Ä¢ Sessions needed: ${sessionsToSchedule.length}\n`;
                        output.textContent += `    ‚Ä¢ Rooms available: ${constraints.rooms.length}\n`;
                        output.textContent += `    ‚Ä¢ Max parallel sessions: ${constraints.rooms.length} (limited by rooms)\n`;
                        
                        const mostConflicts = Math.max(
                            debug.teacherConflicts || 0,
                            debug.roomConflicts || 0,
                            debug.classConflicts || 0,
                            debug.restrictedConflicts || 0
                        );
                        
                        if ((debug.teacherConflicts || 0) === mostConflicts && mostConflicts > 0) {
                            output.textContent += `\n  üí° Suggestion: Add more teachers or increase teacher hours\n`;
                        } else if ((debug.roomConflicts || 0) === mostConflicts && mostConflicts > 0) {
                            output.textContent += `\n  üí° Suggestion: Add more rooms\n`;
                        } else if ((debug.classConflicts || 0) === mostConflicts && mostConflicts > 0) {
                            output.textContent += `\n  üí° Suggestion: Class has too many sessions - reduce subject hours or add available days\n`;
                        } else if ((debug.restrictedConflicts || 0) === mostConflicts && mostConflicts > 0) {
                            output.textContent += `\n  üí° Suggestion: Too many English/Maths sessions - only 1 allowed per time slot across all classes\n`;
                        }
                    } else {
                        output.textContent += `\n  ‚ö†Ô∏è No valid slots found - check teacher availability and class days\n`;
                    }
                    
                    return null;
                }
                
                output.textContent += `‚úÖ Succeeded with relaxed variety\n\n`;
            }
            
            let schedule = result.schedule;
            let totalVarietyCost = result.totalVarietyCost;
            
            // Add Work Placement sessions for T-Level groups
            output.textContent += 'üíº Adding Work Placement Days (T-Levels)...\n';
            
            let workPlacementCount = 0;
            let workPlacementSessions = 0;
            
            for (const studentClass of constraints.classes) {
                const config = constraints.groupConfigs[studentClass] || {};
                
                if (config.workPlacement && config.workPlacementDay) {
                    const wpDay = config.workPlacementDay;
                    output.textContent += `  ${studentClass}: Work Placement on ${wpDay}\n`;
                    
                    for (const time of constraints.timeSlots) {
                        schedule.push({
                            teacher: 'Industry Placement',
                            class: studentClass,
                            subject: 'Work Placement',
                            day: wpDay,
                            time: time,
                            room: 'Employer Site',
                            isWorkPlacement: true
                        });
                        workPlacementSessions++;
                    }
                    
                    output.textContent += `    ‚úÖ Full day scheduled\n`;
                    workPlacementCount++;
                }
            }
            
            if (workPlacementCount === 0) {
                output.textContent += '  No T-Level work placements configured\n';
            }
            
            const endTime = performance.now();
            
            // Calculate variety metrics
            output.textContent += '\nüìä Variety Analysis:\n';
            
            // Check subject distribution per class per day
            let backToBackCount = 0;
            let sameSubjectSameDayMax = 0;
            
            for (const className of constraints.classes) {
                const classScheduleItems = schedule.filter(s => 
                    s.class === className || (s.combinedGroups && s.combinedGroups.includes(className))
                );
                
                for (const day of constraints.days) {
                    const dayItems = classScheduleItems.filter(s => s.day === day && !s.isWorkPlacement);
                    dayItems.sort((a, b) => constraints.timeSlots.indexOf(a.time) - constraints.timeSlots.indexOf(b.time));
                    
                    // Check for back-to-back same subject
                    for (let i = 1; i < dayItems.length; i++) {
                        if (dayItems[i].subject === dayItems[i-1].subject) {
                            backToBackCount++;
                        }
                    }
                    
                    // Check max same subject per day
                    const subjectCounts = {};
                    dayItems.forEach(s => {
                        subjectCounts[s.subject] = (subjectCounts[s.subject] || 0) + 1;
                    });
                    const maxSubject = Math.max(0, ...Object.values(subjectCounts));
                    if (maxSubject > sameSubjectSameDayMax) sameSubjectSameDayMax = maxSubject;
                }
            }
            
            output.textContent += `  Back-to-back same subject: ${backToBackCount} (ideal: 0)\n`;
            output.textContent += `  Max same subject per day: ${sameSubjectSameDayMax} (ideal: 1)\n`;
            output.textContent += `  Total variety cost: ${totalVarietyCost} (lower is better)\n`;
            output.textContent += `  Time: ${(endTime - startTime).toFixed(0)}ms\n`;
            output.textContent += `\n‚úÖ ILP solution found with ${schedule.length} assignments\n`;
            
            return schedule;
        }

        // Helper function to build combined sessions map
        function buildCombinedSessionsMap(combinedClasses) {
            const map = {};
            
            for (const combo of combinedClasses) {
                if (combo.groups.length < 2) continue;
                
                const primaryGroup = combo.groups[0];
                const otherGroups = combo.groups.slice(1);
                
                const primaryKey = `${primaryGroup}-${combo.subject}`;
                if (!map[primaryKey]) {
                    map[primaryKey] = { reducedBy: 0, combineWith: [], isPrimary: true, combinedSessions: 0 };
                }
                map[primaryKey].combineWith.push(...otherGroups);
                map[primaryKey].combinedSessions = combo.sessions;
                
                for (const otherGroup of otherGroups) {
                    const otherKey = `${otherGroup}-${combo.subject}`;
                    if (!map[otherKey]) {
                        map[otherKey] = { reducedBy: 0, combineWith: [], isPrimary: false };
                    }
                    map[otherKey].reducedBy += combo.sessions;
                }
            }
            
            return map;
        }

        function getAvailableDaysForClass(className) {
            const group = className[className.length - 1].toUpperCase();
            const daysOff = constraints.groupDayOff[group];
            const config = constraints.groupConfigs[className] || {};
            
            let excludedDays = [];
            
            // Add regular days off
            if (daysOff) {
                const daysOffArray = Array.isArray(daysOff) ? daysOff : [daysOff];
                excludedDays = [...daysOffArray];
            }
            
            // Add work placement day (T-Level groups have this day at employer site)
            if (config.workPlacement && config.workPlacementDay) {
                if (!excludedDays.includes(config.workPlacementDay)) {
                    excludedDays.push(config.workPlacementDay);
                }
            }
            
            if (excludedDays.length > 0) {
                return constraints.days.filter(d => !excludedDays.includes(d));
            }
            return [...constraints.days];
        }

        function displaySchedule() {
            const output = document.getElementById('scheduleOutput');
            output.textContent = 'üéØ PERFECT SCHEDULE GENERATED!\n';
            output.textContent += '='.repeat(80) + '\n\n';
            
            // Show constraints
            const totalPerClass = Object.values(constraints.requirements).reduce((a, b) => a + b, 0);
            output.textContent += `üìä Applied Constraints:\n`;
            output.textContent += `  Classes: ${constraints.classes.length}\n`;
            output.textContent += `  Days: ${constraints.days.length}\n`;
            output.textContent += `  Time Slots: ${constraints.timeSlots.length}\n`;
            output.textContent += `  Hours per Class: ${totalPerClass}\n\n`;
            
            // Day-off info
            if (Object.keys(constraints.groupDayOff).length > 0) {
                output.textContent += 'üìÖ Group Day-Off Schedule:\n';
                Object.entries(constraints.groupDayOff).sort().forEach(([group, daysOff]) => {
                    const classesInGroup = constraints.classes.filter(c => c.endsWith(group));
                    if (classesInGroup.length > 0) {
                        const daysOffArray = Array.isArray(daysOff) ? daysOff : [daysOff];
                        output.textContent += `  Group ${group} (${classesInGroup.join(', ')}): ${daysOffArray.join(', ')} OFF\n`;
                    }
                });
                output.textContent += '\n';
            }
            
            // Work Placement info
            const workPlacementGroups = constraints.classes.filter(cls => {
                const config = constraints.groupConfigs[cls] || {};
                return config.workPlacement && config.workPlacementDay;
            });
            
            if (workPlacementGroups.length > 0) {
                output.textContent += 'üíº T-Level Work Placement Schedule:\n';
                workPlacementGroups.forEach(cls => {
                    const config = constraints.groupConfigs[cls];
                    const sessionsPerDay = constraints.timeSlots.length;
                    output.textContent += `  ${cls}: Full day (${sessionsPerDay} hrs) Industry Placement on ${config.workPlacementDay}\n`;
                });
                output.textContent += '\n';
            }
            
            // Combined Classes info
            const combinedClasses = constraints.combinedClasses || [];
            if (combinedClasses.length > 0) {
                output.textContent += 'üîó Combined Classes:\n';
                combinedClasses.forEach(combo => {
                    if (combo.groups.length >= 2) {
                        output.textContent += `  ${combo.groups.join(' + ')}: ${combo.sessions}x shared ${combo.subject}\n`;
                    }
                });
                output.textContent += '\n';
            }
            
            // Group by day
            const scheduleByDay = {};
            schedule.forEach(s => {
                if (!scheduleByDay[s.day]) scheduleByDay[s.day] = [];
                scheduleByDay[s.day].push(s);
            });
            
            // Display by day
            for (const day of constraints.days) {
                if (!scheduleByDay[day]) continue;
                
                output.textContent += `üìÖ ${day}\n`;
                output.textContent += '-'.repeat(80) + '\n';
                
                const daySchedule = scheduleByDay[day].sort((a, b) => 
                    constraints.timeSlots.indexOf(a.time) - constraints.timeSlots.indexOf(b.time)
                );
                
                daySchedule.forEach(s => {
                    const combinedIndicator = s.isCombined ? ' üîó' : '';
                    const classDisplay = s.class.length > 10 ? s.class.substring(0, 10) : s.class.padEnd(10);
                    output.textContent += `  ${s.time.padEnd(12)} | ${classDisplay} | ${s.subject.padEnd(12)} | ${s.teacher.padEnd(15)} | ${s.room}${combinedIndicator}\n`;
                });
                
                output.textContent += '\n';
            }
            
            // Verification
            output.textContent += '\nüìä VERIFICATION\n';
            output.textContent += '='.repeat(80) + '\n\n';
            
            // Day-off verification
            if (Object.keys(constraints.groupDayOff).length > 0) {
                output.textContent += 'üìÖ Day-Off Verification:\n';
                let dayOffPerfect = true;
                
                constraints.classes.forEach(className => {
                    const group = className[className.length - 1].toUpperCase();
                    const daysOff = constraints.groupDayOff[group];
                    const config = constraints.groupConfigs[className] || {};
                    
                    if (daysOff) {
                        const daysOffArray = Array.isArray(daysOff) ? daysOff : [daysOff];
                        let classViolations = [];
                        let workPlacementInfo = '';
                        
                        daysOffArray.forEach(dayOff => {
                            // Exclude work placement sessions from violations (they're intentionally on day off)
                            const sessionsOnDayOff = schedule.filter(s => 
                                s.class === className && s.day === dayOff && !s.isWorkPlacement
                            );
                            
                            // Check if this day has work placement
                            if (config.workPlacement && config.workPlacementDay === dayOff) {
                                workPlacementInfo = ` (üíº WP on ${dayOff})`;
                            }
                            
                            if (sessionsOnDayOff.length > 0) {
                                classViolations.push(`${sessionsOnDayOff.length} on ${dayOff}`);
                                dayOffPerfect = false;
                            }
                        });
                        
                        if (classViolations.length > 0) {
                            output.textContent += `  ‚ùå ${className}: ${classViolations.join(', ')}${workPlacementInfo}\n`;
                        } else {
                            output.textContent += `  ‚úÖ ${className}: ${daysOffArray.join(', ')} free${workPlacementInfo}\n`;
                        }
                    }
                });
                
                if (dayOffPerfect) {
                    output.textContent += '  ‚úÖ All day-off constraints satisfied!\n';
                }
                output.textContent += '\n';
            }
            
            // Class breakdown
            output.textContent += 'üìö Class Requirements:\n';
            let allClassesPerfect = true;
            
            constraints.classes.forEach(className => {
                // Get sessions where this class is directly named
                const directSessions = schedule.filter(s => s.class === className);
                
                // Also get sessions where this class is part of a combined group
                const combinedSessions = schedule.filter(s => 
                    s.isCombined && 
                    s.combinedGroups && 
                    s.combinedGroups.includes(className)
                );
                
                const subjectCounts = {};
                let wpHours = 0;
                let combinedHours = 0;
                
                // Count direct sessions
                directSessions.forEach(s => {
                    if (s.isWorkPlacement) {
                        wpHours++;
                    } else {
                        subjectCounts[s.subject] = (subjectCounts[s.subject] || 0) + 1;
                    }
                });
                
                // Count combined sessions (these count toward this class's hours too)
                combinedSessions.forEach(s => {
                    subjectCounts[s.subject] = (subjectCounts[s.subject] || 0) + 1;
                    combinedHours++;
                });
                
                let allOk = true;
                for (const [subject, required] of Object.entries(constraints.requirements)) {
                    if ((subjectCounts[subject] || 0) < required) {
                        allOk = false;
                        break;
                    }
                }
                
                const status = allOk ? '‚úÖ' : '‚ùå';
                if (!allOk) allClassesPerfect = false;
                
                const subjectStr = Object.keys(constraints.requirements)
                    .map(s => `${s[0]}:${subjectCounts[s] || 0}`)
                    .join(' ');
                
                const wpIndicator = wpHours > 0 ? ` +üíº${wpHours}h` : '';
                const combinedIndicator = combinedHours > 0 ? ` +üîó${combinedHours}h` : '';
                const totalHours = directSessions.length + combinedHours;
                output.textContent += `  ${status} ${className}: ${totalHours}h (${subjectStr}${wpIndicator}${combinedIndicator})\n`;
            });
            
            // Work Placement verification
            const wpGroups = constraints.classes.filter(cls => {
                const config = constraints.groupConfigs[cls] || {};
                return config.workPlacement && config.workPlacementDay;
            });
            
            if (wpGroups.length > 0) {
                output.textContent += '\nüíº Work Placement Verification:\n';
                let allWpOk = true;
                
                wpGroups.forEach(className => {
                    const config = constraints.groupConfigs[className];
                    const wpSessions = schedule.filter(s => s.class === className && s.isWorkPlacement);
                    const expectedSessions = constraints.timeSlots.length;
                    
                    if (wpSessions.length === expectedSessions) {
                        output.textContent += `  ‚úÖ ${className}: Full day (${wpSessions.length}/${expectedSessions} hrs) on ${config.workPlacementDay}\n`;
                    } else if (wpSessions.length > 0) {
                        output.textContent += `  ‚ö†Ô∏è ${className}: Partial day (${wpSessions.length}/${expectedSessions} hrs) on ${config.workPlacementDay}\n`;
                    } else {
                        output.textContent += `  ‚ùå ${className}: Work Placement not scheduled!\n`;
                        allWpOk = false;
                    }
                });
                
                if (allWpOk) {
                    output.textContent += '  ‚úÖ All T-Level work placements scheduled!\n';
                }
            }
            
            // Teacher hours
            output.textContent += '\nüë®‚Äçüè´ Teacher Hours:\n';
            let allTeachersPerfect = true;
            
            // Calculate how many sessions were saved by combined classes
            const combinedClassesList = constraints.combinedClasses || [];
            let totalSavedSessions = 0;
            combinedClassesList.forEach(combo => {
                if (combo.groups.length >= 2) {
                    totalSavedSessions += combo.sessions * (combo.groups.length - 1);
                }
            });
            
            // Total scheduled vs total teacher capacity
            const totalScheduledSessions = schedule.filter(s => !s.isWorkPlacement).length;
            const totalTeacherCapacity = teachers.reduce((sum, t) => sum + t.maxHours, 0);
            
            if (totalSavedSessions > 0) {
                output.textContent += `  ‚ÑπÔ∏è Combined classes saved ${totalSavedSessions} sessions\n`;
                output.textContent += `  ‚ÑπÔ∏è Total sessions: ${totalScheduledSessions} | Teacher capacity: ${totalTeacherCapacity}\n\n`;
            }
            
            teachers.forEach(t => {
                const teacherSessions = schedule.filter(s => s.teacher === t.name);
                const combinedHours = teacherSessions.filter(s => s.isCombined).length;
                const hours = teacherSessions.length;
                
                // With combined classes, teachers may have fewer hours than max - that's OK
                // Only mark as problem if they have MORE than max, or if no combined savings and not at max
                let status;
                if (hours === t.maxHours) {
                    status = '‚úÖ';
                } else if (hours > t.maxHours) {
                    status = '‚ùå';
                    allTeachersPerfect = false;
                } else if (totalSavedSessions > 0) {
                    // With combined classes, fewer hours is expected
                    status = '‚úÖ';
                } else {
                    status = '‚ùå';
                    allTeachersPerfect = false;
                }
                
                const combinedNote = combinedHours > 0 ? ` (incl. ${combinedHours} combined)` : '';
                output.textContent += `  ${status} ${t.name}: ${hours}/${t.maxHours}${combinedNote}\n`;
            });
            
            // Combined Classes verification
            if (combinedClassesList.length > 0) {
                output.textContent += '\nüîó Combined Classes Verification:\n';
                
                combinedClassesList.forEach(combo => {
                    if (combo.groups.length < 2) return;
                    
                    const groupsStr = combo.groups.join(' + ');
                    const combinedSessionsFound = schedule.filter(s => 
                        s.isCombined && 
                        s.subject === combo.subject &&
                        s.combinedGroups &&
                        combo.groups.every(g => s.combinedGroups.includes(g))
                    ).length;
                    
                    const status = combinedSessionsFound >= combo.sessions ? '‚úÖ' : '‚ö†Ô∏è';
                    output.textContent += `  ${status} ${groupsStr}: ${combinedSessionsFound}/${combo.sessions} shared ${combo.subject} sessions\n`;
                });
            }
            
            // Final verdict
            output.textContent += '\n';
            const dayOffOk = Object.keys(constraints.groupDayOff).length === 0 || 
                schedule.every(s => {
                    if (s.isWorkPlacement) return true; // Work placement allowed on day off
                    if (s.isCombined) return true; // Combined classes checked separately
                    const group = s.class[s.class.length - 1].toUpperCase();
                    const daysOff = constraints.groupDayOff[group];
                    if (!daysOff) return true;
                    const daysOffArray = Array.isArray(daysOff) ? daysOff : [daysOff];
                    return !daysOffArray.includes(s.day);
                });
            
            // Count work placements and combined
            const wpCount = schedule.filter(s => s.isWorkPlacement).length;
            const combinedCount = schedule.filter(s => s.isCombined).length;
            const wpExpected = wpGroups.length;
            
            if (allTeachersPerfect && allClassesPerfect && dayOffOk) {
                output.textContent += 'üéâ PERFECT! All constraints satisfied!\n';
                let wpMsg = wpCount > 0 ? `\n‚úì ${wpCount} T-Level work placement sessions` : '';
                let combinedMsg = combinedCount > 0 ? `\n‚úì ${combinedCount} combined class sessions (saved ${totalSavedSessions} sessions)` : '';
                let teacherNote = totalSavedSessions > 0 ? '\n‚úì Teacher hours adjusted for combined classes' : '\n‚úì All teachers at exact hours';
                alert(`‚úÖ PERFECT SCHEDULE!\n${teacherNote}\n‚úì All classes have correct requirements\n‚úì All day-off constraints satisfied\n‚úì Zero conflicts${wpMsg}${combinedMsg}\n\nTotal: ${schedule.length} assignments`);
            } else {
                output.textContent += '‚ö†Ô∏è Some constraints not perfectly met\n';
                alert(`Schedule created: ${schedule.length} assignments\nSome constraints may need adjustment`);
            }
        }

        function clearSchedule() {
            schedule = [];
            document.getElementById('scheduleOutput').textContent = 'Click "GENERATE PERFECT SCHEDULE" to create your schedule...';
        }

        function exportToPDF() {
            if (schedule.length === 0) {
                alert('Please generate a schedule first!');
                return;
            }
            
            // Create a printable version
            let html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Perfect Class Schedule</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #667eea; text-align: center; }
                        h2 { color: #34495e; margin-top: 30px; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                        th { background: #34495e; color: white; padding: 10px; text-align: left; }
                        td { padding: 8px; border-bottom: 1px solid #ddd; }
                        tr:nth-child(even) { background: #f8f9fa; }
                        .combined { background: #e8f4fd; }
                        .summary { background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
                        .hours-summary { font-size: 12px; color: #666; margin-bottom: 10px; }
                        @media print { body { padding: 0; } }
                    </style>
                </head>
                <body>
                    <h1>üéØ Perfect Class Schedule</h1>
                    <p style="text-align: center;">Generated: ${new Date().toLocaleString()}</p>
                    
                    <div class="summary">
                        <strong>Configuration:</strong><br>
                        Classes: ${constraints.classes.length} | 
                        Days: ${constraints.days.length} | 
                        Time Slots: ${constraints.timeSlots.length} | 
                        Total Sessions: ${schedule.length}
                    </div>
            `;
            
            // For each class, gather their sessions including combined ones
            for (const className of constraints.classes.sort()) {
                // Get direct sessions
                const directSessions = schedule.filter(s => s.class === className);
                
                // Get combined sessions where this class is part of the group
                const combinedSessions = schedule.filter(s => 
                    s.isCombined && 
                    s.combinedGroups && 
                    s.combinedGroups.includes(className)
                );
                
                // Merge all sessions for this class
                const allSessions = [...directSessions, ...combinedSessions];
                
                if (allSessions.length === 0) continue;
                
                // Count hours
                const directHours = directSessions.length;
                const combinedHours = combinedSessions.length;
                const totalHours = directHours + combinedHours;
                
                html += `<h2>${className} Schedule</h2>`;
                html += `<p class="hours-summary">Total: ${totalHours} hours`;
                if (combinedHours > 0) {
                    html += ` (${directHours} direct + ${combinedHours} combined)`;
                }
                html += `</p>`;
                html += `<table><tr><th>Day</th><th>Time</th><th>Subject</th><th>Teacher</th><th>Room</th><th>Notes</th></tr>`;
                
                // Group by day
                const classScheduleByDay = {};
                allSessions.forEach(s => {
                    if (!classScheduleByDay[s.day]) classScheduleByDay[s.day] = [];
                    classScheduleByDay[s.day].push(s);
                });
                
                for (const day of constraints.days) {
                    if (!classScheduleByDay[day]) continue;
                    
                    const daySessions = classScheduleByDay[day].sort((a, b) => 
                        constraints.timeSlots.indexOf(a.time) - constraints.timeSlots.indexOf(b.time)
                    );
                    
                    daySessions.forEach((s, i) => {
                        const isCombined = s.isCombined && s.combinedGroups;
                        const rowClass = isCombined ? 'combined' : '';
                        const notes = isCombined ? `Combined with ${s.combinedGroups.filter(g => g !== className).join(', ')}` : 
                                      s.isWorkPlacement ? 'Work Placement' : '';
                        
                        html += `<tr class="${rowClass}">
                            <td>${i === 0 ? day : ''}</td>
                            <td>${s.time}</td>
                            <td>${s.subject}</td>
                            <td>${s.teacher}</td>
                            <td>${s.room}</td>
                            <td>${notes}</td>
                        </tr>`;
                    });
                }
                
                html += `</table>`;
            }
            
            html += `</body></html>`;
            
            // Open in new window for printing
            const printWindow = window.open('', '_blank');
            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.print();
        }
    </script>
</body>
</html>
